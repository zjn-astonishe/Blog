---
title: Linux内核的I2C子系统详解 - 代码流程分析(以RK3568为例)
date: 2022-08-18 17:34:01 +0800
categories: [Linux, I2C, 设备驱动开发]
tag: [Linux设备驱动开发, I2C]
mathjax: true
---

# 1. Linux内核里的I2C驱动框架

![Linux内核里I2C驱动框架](https://github.com/zjn-astonishe/Linux_Share/blob/master/Image/image/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/%E5%9B%BE%E7%89%872.png?raw=true)

每一个i2c_adapter对应一条实际的I2C总线。在总线上挂载着I2C设备实物，每个I2C设备对应一个i2c_client，一个i2c_client只能挂载在一个i2c_driver。一般来说，一个i2c_driver可以匹配多个i2c_client，会给每个I2C设备注册设备节点(以字符设备节点为例)，向用户层提供标准操作接口，如`write/read/ioctl`。通过调用i2c_adapter提供的通信方法，完成对I2C设备的操作。

根据上图展示的Linux内核里的I2C驱动框架，可以总结出I2C驱动框架的构建流程如下：

## 1.1. 注册I2C子系统核心层(主要是注册I2C总线)

I2C作为物理总线，通过调用`postcore_initcall()`函数将`i2c_init()`函数注册到系统中，使得在内核启动过程中便会调用初始化函数`i2c_init()`完成I2C总线注册(SPI同理)。

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-base.c */
static int __init i2c_init(void)
{
	int retval;

	retval = of_alias_get_highest_id("i2c");

	down_write(&__i2c_board_lock);
	if (retval >= __i2c_first_dynamic_bus_num)
		__i2c_first_dynamic_bus_num = retval + 1;
	up_write(&__i2c_board_lock);

	retval = bus_register(&i2c_bus_type);       // 注册I2C总线
	if (retval)
		return retval;

	is_registered = true;

#ifdef CONFIG_I2C_COMPAT
	i2c_adapter_compat_class = class_compat_register("i2c-adapter");
	if (!i2c_adapter_compat_class) {
		retval = -ENOMEM;
		goto bus_err;
	}
#endif
	retval = i2c_add_driver(&dummy_driver);         // 注册一个空驱动
	if (retval)
		goto class_err;

	if (IS_ENABLED(CONFIG_OF_DYNAMIC))
		WARN_ON(of_reconfig_notifier_register(&i2c_of_notifier));
	if (IS_ENABLED(CONFIG_ACPI))
		WARN_ON(acpi_reconfig_notifier_register(&i2c_acpi_notifier));

	return 0;

class_err:
#ifdef CONFIG_I2C_COMPAT
	class_compat_unregister(i2c_adapter_compat_class);
bus_err:
#endif
	is_registered = false;
	bus_unregister(&i2c_bus_type);
	return retval;
}
```

I2C总线上分别存储了i2c_driver链和i2c_client链。当任何一个i2c_driver或者i2c_client去注册时，I2C总线都会调用`i2c_device_match()`函数对`i2c_client.name`和`i2c_driver.id_table[].name`进行循环匹配。

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-base.c */
struct bus_type i2c_bus_type = {
	.name		= "i2c",
	.match		= i2c_device_match,         // 负责总线上的device和driver匹配
	.probe		= i2c_device_probe,         // 在匹配成功后会执行以完成注册的收尾工作
	.remove		= i2c_device_remove,
	.shutdown	= i2c_device_shutdown,
};
EXPORT_SYMBOL_GPL(i2c_bus_type);        // 模块导出，可供其他模块使用
// 负责总线上的device和driver匹配的函数
static int i2c_device_match(struct device *dev, struct device_driver *drv)
{
	struct i2c_client	*client = i2c_verify_client(dev);
	struct i2c_driver	*driver;


	/* Attempt an OF style match */
	if (i2c_of_match_device(drv->of_match_table, client))
		return 1;

	/* Then ACPI style match */
	if (acpi_driver_match_device(dev, drv))
		return 1;

	driver = to_i2c_driver(drv);                    // 找到i2c_driver

	/* Finally an I2C match */
	if (i2c_match_id(driver->id_table, client))     // 用i2c_driver的id_table和device匹配。驱动名多个，但设备名只有一个，说明一个驱动可以对应多个设备(尤其是同一类型)
		return 1;

	return 0;
}
```

由`i2c_device_match()`函数的源码可知：如果`i2c_driver.id_table[]`中没有能够和`client`匹配的，函数将直接返回。如果能够匹配，则返回1。并且I2C总线在后续会调用`probe()`函数完成注册的收尾工作。

但是要搞清楚`match()`和`probe()`函数是何时被何者所调用的，则还需进行深入了解。根据描述知道`probe()`函数执行于`match()`函数之后，且匹配触发的前提是要有i2c_driver或者i2c_client注册。所以尝试从i2c_driver的注册代码中寻找答案。

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-base.c */
/*
 * An i2c_driver is used with one or more i2c_client (device) nodes to access
 * i2c slave chips, on a bus instance associated with some i2c_adapter.
 */
int i2c_register_driver(struct module *owner, struct i2c_driver *driver)
{
	...
	driver->driver.bus = &i2c_bus_type;
	INIT_LIST_HEAD(&driver->clients);
	...
	/* When registration returns, the driver core
	 * will have called probe() for all matching-but-unbound devices.
	 */
	res = driver_register(&driver->driver);     // 实际注册位置
	if (res)
		return res;
    ...
}
EXPORT_SYMBOL(i2c_register_driver);
```

注意到`i2c_register_driver`函数中实际是调用了`driver_register()`函数完成注册，继续寻找函数中有关总线的调用。

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/base/driver.c */
/**
 * driver_register - register driver with bus
 * @drv: driver to register
 *
 * We pass off most of the work to the bus_add_driver() call,
 * since most of the things we have to do deal with the bus
 * structures.
 */
int driver_register(struct device_driver *drv)
{
	...
	ret = bus_add_driver(drv);              // 在总线上添加传递的驱动(将驱动添加到总线的驱动链表中)
	...
}
EXPORT_SYMBOL_GPL(driver_register);
```

`driver_register()`函数中调用了`bus_add_driver()`函数，将驱动添加到总线上，持续跟踪直到找到有关`match`和`probe`的函数。

```C++

/**
 * bus_add_driver - Add a driver to the bus.
 * @drv: driver.
 */
int bus_add_driver(struct device_driver *drv)
{
	...
	if (drv->bus->p->drivers_autoprobe)     // 提到probe
    {
		error = driver_attach(drv);         // 跟踪driver_attach();
		if (error)
			goto out_unregister;
	}
	...
}
```

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/base/dd.c */
/**
 * driver_attach - try to bind driver to devices.
 * @drv: driver.
 *
 * Walk the list of devices that the bus has on it and try to
 * match the driver with each one.  If driver_probe_device()
 * returns 0 and the @dev->driver is set, we've found a
 * compatible pair.
 */
int driver_attach(struct device_driver *drv)
{
	return bus_for_each_dev(drv->bus, NULL, drv, __driver_attach);  // 继续跟踪发现实际是在调用__driver_attach();
}
EXPORT_SYMBOL_GPL(driver_attach);
```

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/base/dd.c */
static int __driver_attach(struct device *dev, void *data)
{
	struct device_driver *drv = data;
	int ret;

	/*
	 * Lock device and try to bind to it. We drop the error
	 * here and always return 0, because we need to keep trying
	 * to bind to devices and some drivers will return an error
	 * simply if it didn't support the device.
	 *
	 * driver_probe_device() will spit a warning if there
	 * is an error.
	 */

	ret = driver_match_device(drv, dev);        // 驱动和设备匹配
	if (ret == 0) {
		/* no match */
		return 0;
	} else if (ret == -EPROBE_DEFER) {
		dev_dbg(dev, "Device match requests probe deferral\n");
		driver_deferred_probe_add(dev);
	} else if (ret < 0) {
		dev_dbg(dev, "Bus failed to match device: %d\n", ret);
		return ret;
	} /* ret > 0 means positive match */

	......

    device_driver_attach(drv, dev);
	return 0;
}
```
```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/base/dd.c */
/**
 * device_driver_attach - attach a specific driver to a specific device
 * @drv: Driver to attach
 * @dev: Device to attach it to
 *
 * Manually attach driver to a device. Will acquire both @dev lock and
 * @dev->parent lock if needed.
 */
int device_driver_attach(struct device_driver *drv, struct device *dev)
{
	int ret = 0;
	__device_driver_lock(dev, dev->parent);
	/*
	 * If device has been removed or someone has already successfully
	 * bound a driver before us just skip the driver probe call.
	 */
	if (!dev->p->dead && !dev->driver)
		ret = driver_probe_device(drv, dev);
	__device_driver_unlock(dev, dev->parent);
	return ret;
}
```
```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/base/dd.c */
/**
 * driver_probe_device - attempt to bind device & driver together
 * @drv: driver to bind a device to
 * @dev: device to try to bind to the driver
 *
 * This function returns -ENODEV if the device is not registered,
 * 1 if the device is bound successfully and 0 otherwise.
 *
 * This function must be called with @dev lock held.  When called for a
 * USB interface, @dev->parent lock must be held as well.
 *
 * If the device has a parent, runtime-resume the parent before driver probing.
 */
int driver_probe_device(struct device_driver *drv, struct device *dev)
{
    ...
	pm_runtime_barrier(dev);
	if (initcall_debug)
		ret = really_probe_debug(dev, drv);
	else
		ret = really_probe(dev, drv);
	...
}
```

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/base/base.h */ 
static inline int driver_match_device(struct device_driver *drv,
				      struct device *dev)
{
	return drv->bus->match ? drv->bus->match(dev, drv) : 1;
}
```

至此，可知是`driver_match_device`函数调用了I2C总线的`match()`函数完成对驱动和设备的匹配工作。

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/base/dd.c */
static int really_probe(struct device *dev, struct device_driver *drv)
{
	...
	if (dev->bus->probe) {
		ret = dev->bus->probe(dev);
		if (ret)
			goto probe_failed;
	} else if (drv->probe) {
		ret = drv->probe(dev);
		if (ret)
			goto probe_failed;
	}
    ...
}
```

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-base.c */
static int i2c_device_probe(struct device *dev)
{
	struct i2c_client	*client = i2c_verify_client(dev);   // 设备
	struct i2c_driver	*driver;                            // 驱动
	int status;

	if (!client)           // 找不到设备，失败，直接返回
		return 0;

	client->irq = client->init_irq;

	if (!client->irq) {
		int irq = -ENOENT;

		if (client->flags & I2C_CLIENT_HOST_NOTIFY) {
			dev_dbg(dev, "Using Host Notify IRQ\n");
			/* Keep adapter active when Host Notify is required */
			pm_runtime_get_sync(&client->adapter->dev);
			irq = i2c_smbus_host_notify_to_irq(client);
		} else if (dev->of_node) {
			irq = of_irq_get_byname(dev->of_node, "irq");
			if (irq == -EINVAL || irq == -ENODATA)
				irq = of_irq_get(dev->of_node, 0);
		} else if (ACPI_COMPANION(dev)) {
			irq = i2c_acpi_get_irq(client);
		}
		if (irq == -EPROBE_DEFER) {
			status = irq;
			goto put_sync_adapter;
		}

		if (irq < 0)
			irq = 0;

		client->irq = irq;
	}

	driver = to_i2c_driver(dev->driver);

	/*
	 * An I2C ID table is not mandatory, if and only if, a suitable OF
	 * or ACPI ID table is supplied for the probing device.
	 */
	if (!driver->id_table &&
	    !acpi_driver_match_device(dev, dev->driver) &&
	    !i2c_of_match_device(dev->driver->of_match_table, client)) {
		status = -ENODEV;
		goto put_sync_adapter;
	}

	if (client->flags & I2C_CLIENT_WAKE) {
		int wakeirq;

		wakeirq = of_irq_get_byname(dev->of_node, "wakeup");
		if (wakeirq == -EPROBE_DEFER) {
			status = wakeirq;
			goto put_sync_adapter;
		}

		device_init_wakeup(&client->dev, true);

		if (wakeirq > 0 && wakeirq != client->irq)
			status = dev_pm_set_dedicated_wake_irq(dev, wakeirq);
		else if (client->irq > 0)
			status = dev_pm_set_wake_irq(dev, client->irq);
		else
			status = 0;

		if (status)
			dev_warn(&client->dev, "failed to set up wakeup irq\n");
	}

	dev_dbg(dev, "probe\n");

	status = of_clk_set_defaults(dev->of_node, false);
	if (status < 0)
		goto err_clear_wakeup_irq;

	status = dev_pm_domain_attach(&client->dev, true);
	if (status)
		goto err_clear_wakeup_irq;

    /**
     * 通过函数指针的方式调用了i2c_driver的probe函数。即当一个device和一个driver匹配上以后还会去执行driver里面的probe函数完成i2c_driver注册的收尾工作
     */
	/**
	 * When there are no more users of probe(),
	 * rename probe_new to probe.
	 */
	if (driver->probe_new)
		status = driver->probe_new(client);
	else if (driver->probe)
		status = driver->probe(client,
				       i2c_match_id(driver->id_table, client));
	else
		status = -EINVAL;

	if (status)
		goto err_detach_pm_domain;

	return 0;

err_detach_pm_domain:
	dev_pm_domain_detach(&client->dev, true);
err_clear_wakeup_irq:
	dev_pm_clear_wake_irq(&client->dev);
	device_init_wakeup(&client->dev, false);
put_sync_adapter:
	if (client->flags & I2C_CLIENT_HOST_NOTIFY)
		pm_runtime_put_sync(&client->adapter->dev);

	return status;
}
```

结合`really_probe()`函数和I2C总线的`i2c_device_probe()`函数，可以知道是i2c_driver在注册的过程中调用了`really_probe()`函数从而调用I2C总线的`i2c_device_probe()`函数，进而调用i2c_driver自己的`probe()`函数，从而完成硬件初始化等后续工作。

## 1.2. 注册i2c_adapter并将其添加到I2C总线

`i2c_adapter`在硬件上对应Soc的I2C控制器，在内核中被认为是一个设备，而其对应驱动即是总线驱动。它向接在I2C控制器上的I2C设备提供在I2C总线上通信的基础方法，通过操作Soc的I2C控制器相关的寄存器实现数据收发。`i2c_adapter`一般通过两种方法注册：

- 一种做法是为I2C适配器创建一个platform设备注册到`platform_bus_type`总线上与I2C适配器的platform驱动匹配，在驱动的probe函数中向I2C总线添加`i2c_adapter`和提供`i2c_algorithm`通信方法。
- 另一种做法是I2C适配器作为pci设备注册到PCI总线上与I2C适配器的pci驱动匹配，在驱动的probe函数中向i2c_bus_type添加`i2c_adapter`和提供`i2c_algorithm`通信方法。

RK平台采用的是第一种方法。总线驱动的文件存储在路径`/home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses`中，RK平台的总线驱动文件为`i2c-rk3x.c`。

### 1.2.1. 关键数据结构定义

- 总线驱动定义

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-rk3x.c */
static struct platform_driver rk3x_i2c_driver = {
    /** .probe()：
     * 当驱动注册完毕，并且匹配成功，则会自动调用该方法对硬件进行初始化操作：
     * a. 注册设备号，并且注册fops(为用户提供设备标示，同时提供文件操作io接口)
     * b. 创建设备节点
     * c. 初始化硬件的各项信息，如ioremap(io地址映射虚拟地址)
     * d. 实现各种io功能接口
     */
    .probe   = rk3x_i2c_probe,      
    .remove  = rk3x_i2c_remove,
    .driver  = {
        .name  = "rk3x-i2c",                // 用于驱动和设备匹配，确保驱动和设备一致，否则无法匹配成功
        .of_match_table = rk3x_i2c_match,   // 匹配表
        .pm = &rk3x_i2c_pm_ops,	            // dev_pm_ops类型的结构体，用来赋值设备完成运行时的电源管理
    },
}; 
```

- 总线驱动通信方法定义
> 因为每家芯片厂商SoC内部的I2C控制器是不一样的，所以 `i2c_algorithm` 中直接涉及硬件层面上的代码都是由芯片商提供。例如：对I2C控制器的寄存器操作。 `i2c_algorithm` 提供的通信函数控制适配器产生特定的访问信号，虽然不同的I2C总线控制器被抽象成不同的 `i2c_adapter` ，但是如果操作方式相同，则可以共享同一个 `i2c_algorithm` 。

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-rk3x.c */
// 总线驱动通信方法定义
static const struct i2c_algorithm rk3x_i2c_algorithm = {
    .master_xfer		= rk3x_i2c_xfer,            // 通信方法，如果不支持I2C访问，则为NULL
    .master_xfer_atomic	= rk3x_i2c_xfer_polling,            // 通信方法，仅使用于原子上下文
    .functionality		= rk3x_i2c_func,            // 检测通信方法支持的功能或协议，设备驱动一般会调用这个回调来确认适配器支持的协议类型
}; 

```

### 1.2.2. 设备树信息

RK3568共有6个I2C控制器，分别为I2C0~I2C5，每个控制器对应不同的寄存器基地址(i2c0是0xfdd40000)， `.compatible` 属性都是 `rockchip, rk3399-i2c` ，即对应了同一个adapter驱动。

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/arch/arm64/boot/dts/rockchip/rk3568.dtsi */
    i2c0: i2c@fdd40000 {
        compatible = "rockchip,rk3399-i2c";
        reg = <0x0 0xfdd40000 0x0 0x1000>;  // 起始地址0xfdd40000, 长度0x10000
        clocks = <&pmucru CLK_I2C0>, <&pmucru PCLK_I2C0>;
        clock-names = "i2c", "pclk";
        interrupts = <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>;  // 中断和触发方式
        pinctrl-names = "default";
        pinctrl-0 = <&i2c0_xfer>;
        #address-cells = <1>;   //表示用一个32位的数来描述地址
        #size-cells = <0>;      //表示用0个32位的数来描述该地址的大小
        status = "disabled";    // 目前状态
    };
    i2c1: i2c@fe5a0000 {
        compatible = "rockchip,rk3399-i2c";
        reg = <0x0 0xfe5a0000 0x0 0x1000>;
        clocks = <&cru CLK_I2C1>, <&cru PCLK_I2C1>;
        clock-names = "i2c", "pclk";
        interrupts = <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>;
        pinctrl-names = "default";
        pinctrl-0 = <&i2c1_xfer>;
        #address-cells = <1>;
        #size-cells = <0>;
        status = "disabled";
    };
    i2c2: i2c@fe5b0000 {
        compatible = "rockchip,rk3399-i2c";
        reg = <0x0 0xfe5b0000 0x0 0x1000>;
        clocks = <&cru CLK_I2C2>, <&cru PCLK_I2C2>;
        clock-names = "i2c", "pclk";
        interrupts = <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
        pinctrl-names = "default";
        pinctrl-0 = <&i2c2m0_xfer>;
        #address-cells = <1>;
        #size-cells = <0>;
        status = "disabled";
    };
    i2c3: i2c@fe5c0000 {
        compatible = "rockchip,rk3399-i2c";
        reg = <0x0 0xfe5c0000 0x0 0x1000>;
        clocks = <&cru CLK_I2C3>, <&cru PCLK_I2C3>;
        clock-names = "i2c", "pclk";
        interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>;
        pinctrl-names = "default";
        pinctrl-0 = <&i2c3m0_xfer>;
        #address-cells = <1>;
        #size-cells = <0>;
        status = "disabled";
    };
    i2c4: i2c@fe5d0000 {
        compatible = "rockchip,rk3399-i2c";
        reg = <0x0 0xfe5d0000 0x0 0x1000>;
        clocks = <&cru CLK_I2C4>, <&cru PCLK_I2C4>;
        clock-names = "i2c", "pclk";
        interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
        pinctrl-names = "default";
        pinctrl-0 = <&i2c4m0_xfer>;
        #address-cells = <1>;
        #size-cells = <0>;
        status = "disabled";
    };
    i2c5: i2c@fe5e0000 {
        compatible = "rockchip,rk3399-i2c";
        reg = <0x0 0xfe5e0000 0x0 0x1000>;
        clocks = <&cru CLK_I2C5>, <&cru PCLK_I2C5>;
        clock-names = "i2c", "pclk";
        interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
        pinctrl-names = "default";
        pinctrl-0 = <&i2c5m0_xfer>;
        #address-cells = <1>;
        #size-cells = <0>;
        status = "disabled";
    };

```

将 `rk3x_i2c_driver` 作为一个 `platform_driver` 注册到内核， `rk3x_i2c_match` 作为结构体中的参数实际是一个记录设备信息的结构体数组。系统启动后会比较DTS中的匹配属性与驱动匹配表中是否相符，如果相符则会进入 `rk3x_i2c_probe` 接口，完成驱动各项参数的初始化。

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-rk3x.c */
// rk3x_i2c_driver结构体中.driver的匹配表参数
static const struct of_device_id rk3x_i2c_match[] = {

    {
        .compatible = "rockchip,rv1108-i2c",
        .data = &rv1108_soc_data
    },
    {
        .compatible = "rockchip,rv1126-i2c",
        .data = &rv1126_soc_data
    },
    {
        .compatible = "rockchip,rk3066-i2c",
        .data = &rk3066_soc_data
    },
    {
        .compatible = "rockchip,rk3188-i2c",
        .data = &rk3188_soc_data
    },
    {
        .compatible = "rockchip,rk3228-i2c",
        .data = &rk3228_soc_data
    },
    {
        .compatible = "rockchip,rk3288-i2c",
        .data = &rk3288_soc_data
    },
    {
        .compatible = "rockchip,rk3399-i2c", // 符合DTS中描述的匹配字符串
        .data = &rk3399_soc_data
    },
    {},

}; 
/**
 * @param usb               设备名
 * @param skel_table        该设备加入到模块中时对应产生的设备搜索符号
 * @return 生成一个名为__mod_pci_device_table局部变量，这个变量指向第二个参数
 */
MODULE_DEVICE_TABLE(of, rk3x_i2c_match); // 两个功能，一是将设备加入到外设队列中，二是告诉程序阅读者该设备是热插拔设备或支持热插拔功能。
```


### 1.2.3. 注册和卸载i2c_adapter

为了提高代码的重用性，消除多余的样板文件。当module_init和module_exit都不做任何特殊操作时，调用宏定义函数 `module_platform_driver` 替换 `module_init` 和 `module_exit` (实际还要调用一次宏定义函数 `module_driver` 才能完成替换)。

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/include/linux/platform_device.h */
/**
 * module_platform_driver() - Helper macro for drivers that don't do
 * anything special in module init/exit.  
 * This eliminates a lot of boilerplate.  
 * Each module may only use this macro once, and
 * calling it replaces module_init() and module_exit()
 */
#define module_platform_driver(__platform_driver) \

    module_driver(__platform_driver, platform_driver_register, \
            platform_driver_unregister)
			
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/include/linux/device/driver.h */
/**
 * module_driver() - Helper macro for drivers that don't do anything
 * special in module init/exit. This eliminates a lot of boilerplate.
 * Each module may only use this macro once, and calling it replaces
 * module_init() and module_exit().
 *
 * @__driver: driver name
 * @__register: register function for this driver type
 * @__unregister: unregister function for this driver type
 * @...: Additional arguments to be passed to __register and __unregister.
 *
 * Use this macro to construct bus specific macros for registering
 * drivers, and do not use it on its own.
 */
#define module_driver(__driver, __register, __unregister, ...) \
// 注册方法，替代module_init()
static int __init __driver##_init(void) \
{ \

    return __register(&(__driver) , ##__VA_ARGS__); \

} \
module_init(__driver##_init); \
// 卸载方法，替代module_exit()
static void __exit __driver##_exit(void) \
{ \

    __unregister(&(__driver) , ##__VA_ARGS__); \

} \
module_exit(__driver##_exit); 

```

### 1.2.4. i2c_adapter相关函数配置
- 注册收尾函数probe()

>`platform_driver` 在注册时会遍历 `platform` 总线上的 `platform_device` ，当条件( `.compatible` 属性或 `id_table` )匹配(通过得分机制，得分最高的最终会匹配成功)时，便会调用 `rk3x_i2c_probe` 函数。如何调用参考上文总线部分的`i2c_driver`的`probe()`函数。

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-rk3x.c */
/**
 * @param pdev: 即i2c_adapter，相当于是挂载在platform总线上的platform_device。
 */
static int rk3x_i2c_probe(struct platform_device *pdev)
{

    struct device_node *np = pdev->dev.of_node;
    const struct of_device_id *match;
    struct rk3x_i2c *i2c;	// 声明一个rk3x_i2c的适配器结构体，是i2c_adapter的进一步封装，相当于面向对象中的继承
    int ret = 0;
    u32 value;
    int irq;
    unsigned long clk_rate;

    /**

     * 采用devm_kzalloc与kzalloc相比，优点在于不用考虑释放问题，由内核完成内存回收工作
     * devm_kzalloc — Resource-managed kzalloc
     * @param pdev: 申请内存的目标设备
     * @param gftp: 申请内存的类型标志，标识内存分配器将要采取的行为。其中GFP_KERNEL最常用，五内存可用时可引起休眠。
     * @return: 成功返回首地址，失败返回NULL
     * 为适配器结构体申请内存，为后续实例化完成基础工作。
     */
    i2c = devm_kzalloc(&pdev->dev, sizeof(struct rk3x_i2c), GFP_KERNEL); 
    if (!i2c)	// 申请失败
        return -ENOMEM; 

    /**

     * 找到rk3x_i2c_match数组里与之匹配的那个struct of_device_id
     * i2c_adapter驱动会兼容多个RK平台(如rk3188/rk3288/rk3399等)的i2c控制器，
     * 各个平台有些差异，差异性的信息可以通过.data这个成员指针保存起来，用到的时候再取出来
     */
    match = of_match_node(rk3x_i2c_match, np); 
    // 取出所匹配的i2c控制器的配置信息
    i2c->soc_data = match->data; 

    /* use common interface to get I2C timing properties */
    i2c_parse_fw_timings(&pdev->dev, &i2c->t, true);

    // i2c_adapter部分成员初始化
    // 名字
    strlcpy(i2c->adap.name, "rk3x-i2c", sizeof(i2c->adap.name));
    // 拥有者
    i2c->adap.owner = THIS_MODULE;
    // 通信方法
    i2c->adap.algo = &rk3x_i2c_algorithm;
    i2c->adap.retries = 3;
    i2c->adap.dev.of_node = np;
    i2c->adap.algo_data = i2c;
    i2c->adap.dev.parent = &pdev->dev;

    i2c->dev = &pdev->dev;

    spin_lock_init(&i2c->lock);
    // 初始化等待队列头部，等待在进程调度中使用
    init_waitqueue_head(&i2c->wait);
    // 通知链机制，在内核重启之前会调用回调函数rk3x_i2c_restart_notify
    i2c->i2c_restart_nb.notifier_call = rk3x_i2c_restart_notify;
    i2c->i2c_restart_nb.priority = 128;
    ret = register_pre_restart_handler(&i2c->i2c_restart_nb);
    if (ret) {
        dev_err(&pdev->dev, "failed to setup i2c restart handler.\n");
        return ret;
    }
    // 从dts中获取设备的物理基址
    i2c->regs = devm_platform_ioremap_resource(pdev, 0);
    if (IS_ERR(i2c->regs))
        return PTR_ERR(i2c->regs);

    /**

        * Switch to new interface if the SoC also offers the old one.
        * The control bit is located in the GRF register space.
        * grf_offset: offset inside the grf regmap for setting the i2c type
        */
    if (i2c->soc_data->grf_offset >= 0) {
        struct regmap *grf; 

        grf = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
        if (!IS_ERR(grf)) {
            int bus_nr;

            /* Try to set the I2C adapter number from dt */
            bus_nr = of_alias_get_id(np, "i2c");
            if (bus_nr < 0) {
                dev_err(&pdev->dev, "rk3x-i2c needs i2cX alias");
                return -EINVAL;
            }

            if (i2c->soc_data == &rv1108_soc_data && bus_nr == 2)
                /* rv1108 i2c2 set grf offset-0x408, bit-10 */
                value = BIT(26) | BIT(10);
            else if (i2c->soc_data == &rv1126_soc_data &&
                    bus_nr == 2)
                /* rv1126 i2c2 set pmugrf offset-0x118, bit-4 */
                value = BIT(20) | BIT(4);
            else
                /* rk3xxx 27+i: write mask, 11+i: value */
                value = BIT(27 + bus_nr) | BIT(11 + bus_nr);

            ret = regmap_write(grf, i2c->soc_data->grf_offset,
                        value);
            if (ret != 0) {
                dev_err(i2c->dev, "Could not write to GRF: %d\n",
                    ret);
                return ret;
            }
        }
    }

    /* IRQ setup(中断设置) */
    irq = platform_get_irq(pdev, 0);	// platform_device结构体中存储有所用到的中断号
    if (irq < 0)
        return irq;

    ret = devm_request_irq(&pdev->dev, irq, rk3x_i2c_irq,
                    0, dev_name(&pdev->dev), i2c);
    if (ret < 0) {
        dev_err(&pdev->dev, "cannot request IRQ\n");
        return ret;
    }

    // 存储用户主动申请的内存区域指针防止丢失
    platform_set_drvdata(pdev, i2c);

    // 平台时钟设置
    if (i2c->soc_data->calc_timings == rk3x_i2c_v0_calc_timings) {
        /* Only one clock to use for bus clock and peripheral clock */
        i2c->clk = devm_clk_get(&pdev->dev, NULL);
        i2c->pclk = i2c->clk;
    } else {
        i2c->clk = devm_clk_get(&pdev->dev, "i2c");
        i2c->pclk = devm_clk_get(&pdev->dev, "pclk");
    }

    if (IS_ERR(i2c->clk))
        return dev_err_probe(&pdev->dev, PTR_ERR(i2c->clk),
                        "Can't get bus clk\n");

    if (IS_ERR(i2c->pclk))
        return dev_err_probe(&pdev->dev, PTR_ERR(i2c->pclk),
                        "Can't get periph clk\n");

    ret = clk_prepare(i2c->clk);
    if (ret < 0) {
        dev_err(&pdev->dev, "Can't prepare bus clk: %d\n", ret);
        return ret;
    }
    ret = clk_prepare(i2c->pclk);
    if (ret < 0) {
        dev_err(&pdev->dev, "Can't prepare periph clock: %d\n", ret);
        goto err_clk;
    }

    i2c->clk_rate_nb.notifier_call = rk3x_i2c_clk_notifier_cb;
    ret = clk_notifier_register(i2c->clk, &i2c->clk_rate_nb);
    if (ret != 0) {
        dev_err(&pdev->dev, "Unable to register clock notifier\n");
        goto err_pclk;
    }

    clk_rate = clk_get_rate(i2c->clk);
    rk3x_i2c_adapt_div(i2c, clk_rate);

    // 向内核添加i2c_adapter
    ret = i2c_add_adapter(&i2c->adap);

    if (ret < 0)
        goto err_clk_notifier;

    return 0;

err_clk_notifier:

    clk_notifier_unregister(i2c->clk, &i2c->clk_rate_nb);

err_pclk:

    clk_unprepare(i2c->pclk);

err_clk:

    clk_unprepare(i2c->clk);
    return ret;

}

```
- 释放函数remove()

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-rk3x.c */
static int rk3x_i2c_remove(struct platform_device *pdev)
{

    // 获得rk3x_i2c_probe中存储的主动申请的内存区域指针
    struct rk3x_i2c *i2c = platform_get_drvdata(pdev);
    // 卸载i2c_adapter
    i2c_del_adapter(&i2c->adap);

    // 注销时钟
    clk_notifier_unregister(i2c->clk, &i2c->clk_rate_nb);
    unregister_pre_restart_handler(&i2c->i2c_restart_nb); 
    clk_unprepare(i2c->pclk);
    clk_unprepare(i2c->clk); 

    return 0;

}

```

- 通信方法函数master_xfer()

> 实现总线上数据传输，rk3x_i2c提供了两种方式来处理阻塞进程唤醒。

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-rk3x.c */
// 使用等待队列实现阻塞进程唤醒
static int rk3x_i2c_xfer(struct i2c_adapter *adap, 

			 struct i2c_msg *msgs, int num)

{

    return rk3x_i2c_xfer_common(adap, msgs, num, false);

}
// 使用poll机制而非等待队列实现阻塞进程唤醒
static int rk3x_i2c_xfer_polling(struct i2c_adapter *adap, 

				 struct i2c_msg *msgs, int num)

{

    return rk3x_i2c_xfer_common(adap, msgs, num, true);

}
static int rk3x_i2c_xfer_common(struct i2c_adapter *adap, 

				struct i2c_msg *msgs, int num, bool polling)

{

    struct rk3x_i2c *i2c = (struct rk3x_i2c *)adap->algo_data;
    unsigned long timeout, flags;
    u32 val;
    int ret = 0;
    int i;

    if (i2c->suspended)
        return -EACCES;

    spin_lock_irqsave(&i2c->lock, flags);
    // 使能时钟
    clk_enable(i2c->clk);
    clk_enable(i2c->pclk);

    i2c->is_last_msg = false;

    /*

        * Process msgs. We can handle more than one message at once (see
        * rk3x_i2c_setup()).
        * i+ret就是指一次循环处理多条msg
        */
    for (i = 0; i < num; i += ret) {
        ret = rk3x_i2c_setup(i2c, msgs + i, num - i);

        // i2c msg处理出错
        if (ret < 0) {
            dev_err(i2c->dev, "rk3x_i2c_setup() failed\n");
            break;
        }
        // ret为本轮已处理的msgs数量，i为过去已处理的msgs数量，如果刚好等于msgs总数，则
        if (i + ret >= num)
            i2c->is_last_msg = true;
        // 启动i2c_adapter
        rk3x_i2c_start(i2c);	
        // 释放自旋锁，并恢复标志寄存器的值为变量flags保存的值
        spin_unlock_irqrestore(&i2c->lock, flags);

        // 区分调用的是rk3x_i2c_xfer还是rk3x_i2c_xfer_polling
        if (!polling) {
            /**

                * 调用rk3x_i2c_xfer, 挂起等待队列头i2c->wait(wait_queue_head_t)。
                * 直到i2c_adapter不再繁忙或者等待超时，则调用wake_up(i2c->wait)会唤醒进程并继续往下执行
                * 如果未超时且i2c_adapter繁忙，则进程会被阻塞
                */

            timeout = wait_event_timeout(i2c->wait, !i2c->busy,
                                msecs_to_jiffies(WAIT_TIMEOUT));
        } else {
            timeout = rk3x_i2c_wait_xfer_poll(i2c);
        }
        // 获得自旋锁，并且备份本地中断和中断状态到flags变量
        spin_lock_irqsave(&i2c->lock, flags);

        // 超时了
        if (timeout == 0) {
            dev_err(i2c->dev, "timeout, ipd: 0x%02x, state: %d\n",
                i2c_readl(i2c, REG_IPD), i2c->state);

            /* Force a STOP condition without interrupt */
            rk3x_i2c_disable_irq(i2c);
            val = i2c_readl(i2c, REG_CON) & REG_CON_TUNING_MASK;
            val |= REG_CON_EN | REG_CON_STOP;
            i2c_writel(i2c, val, REG_CON);

            i2c->state = STATE_IDLE;

            ret = -ETIMEDOUT;
            break;
        }

        // 未超时，但是i2c_adapter运行中产生错误
        if (i2c->error) {
            ret = i2c->error;
            break;
        }
    }

    // 顺利完成i2c通信？
    // 关闭中断
    rk3x_i2c_disable_irq(i2c);
    // 关闭i2c总线
    rk3x_i2c_disable(i2c);
    // 关闭时钟
    clk_disable(i2c->pclk);
    clk_disable(i2c->clk);

    spin_unlock_irqrestore(&i2c->lock, flags);

    // 出错返回ret，成功返回处理msgs的数量
    return ret < 0 ? ret : num;

}

// 使用poll机制而非等待队列
static int rk3x_i2c_wait_xfer_poll(struct rk3x_i2c *i2c)
{

    // ktime_get()得到当前时间，ktime_add_ms来设置超时时间。
    ktime_t timeout = ktime_add_ms(ktime_get(), WAIT_TIMEOUT);

    /**

        * READ_ONCE是一个用来读取变量的宏，为了避免编译器优化导致多线程时读取出错而编写
        * ktime_compare用来确定是否超时
        */
    while (READ_ONCE(i2c->busy) &&
            ktime_compare(ktime_get(), timeout) < 0) {
        // 没超时且i2c_adapter繁忙，则延时等待
        udelay(5); 
        // 设置中断
        rk3x_i2c_irq(0, i2c); 
    }
    // 返回i2c_adapter的状态
    return !i2c->busy; 

}

```

- 功能检测函数func()

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-rk3x.c */
// 无格式i2c-level命令(Pure SMBus适配器不能用这些命令)
#define I2C_FUNC_I2C			0x00000001
// 处理所有的能够被I2C adapter仿真的SMBus命令(RK平台的控制器兼容I2C与SMBus总线)
#define I2C_FUNC_SMBUS_EMUL		(I2C_FUNC_SMBUS_QUICK | \

                                I2C_FUNC_SMBUS_BYTE | \
                                I2C_FUNC_SMBUS_BYTE_DATA | \
                                I2C_FUNC_SMBUS_WORD_DATA | \
                                I2C_FUNC_SMBUS_PROC_CALL | \
                                I2C_FUNC_SMBUS_WRITE_BLOCK_DATA | \
                                I2C_FUNC_SMBUS_I2C_BLOCK | \
                                I2C_FUNC_SMBUS_PEC)

// 熟知的有I2C_M_IGNORE_NAK, I2C_M_REV_DIR_ADDR, I2C_M_NOSTART, I2C_MNO_RD_ACK等flags(I2C寄存器状态？)
#define I2C_FUNC_PROTOCOL_MANGLING	0x00000004 /* I2C_M_IGNORE_NAK etc. */
// 处理SMBus write_quick命令
#define I2C_FUNC_SMBUS_QUICK		0x00010000
//  处理SMBus read_byte & write_byte命令
#define I2C_FUNC_SMBUS_BYTE		(I2C_FUNC_SMBUS_READ_BYTE | \

                                I2C_FUNC_SMBUS_WRITE_BYTE)

// 处理SMBus read_byte_data & write_byte_data命令
#define I2C_FUNC_SMBUS_BYTE_DATA	(I2C_FUNC_SMBUS_READ_BYTE_DATA | \

					                I2C_FUNC_SMBUS_WRITE_BYTE_DATA)

// 处理SMBus read_word_data & write_word_data命令
#define I2C_FUNC_SMBUS_WORD_DATA	(I2C_FUNC_SMBUS_READ_WORD_DATA | \

					                I2C_FUNC_SMBUS_WRITE_WORD_DATA)

// 处理SMBus process_call命令
#define I2C_FUNC_SMBUS_PROC_CALL	0x00800000
// 处理SMBus wrtie_block_data命令
#define I2C_FUNC_SMBUS_WRITE_BLOCK_DATA 0x02000000
// 处理SMBus read_i2c_block_data & write_i2c_block_data命令
#define I2C_FUNC_SMBUS_I2C_BLOCK	(I2C_FUNC_SMBUS_READ_I2C_BLOCK | \

					                I2C_FUNC_SMBUS_WRITE_I2C_BLOCK)

#define I2C_FUNC_SMBUS_PEC		0x00000008
// 处理SMBus read_byte命令
#define I2C_FUNC_SMBUS_READ_BYTE	0x00020000
// 处理SMBus write_byte命令
#define I2C_FUNC_SMBUS_WRITE_BYTE	0x00040000
// 处理SMBus read_byte_data命令
#define I2C_FUNC_SMBUS_READ_BYTE_DATA	0x00080000
// 处理SMBus write_byte_data命令
#define I2C_FUNC_SMBUS_WRITE_BYTE_DATA	0x00100000
// 处理SMBus read_word_data命令
#define I2C_FUNC_SMBUS_READ_WORD_DATA	0x00200000
// 处理SMBus write_word_data命令
#define I2C_FUNC_SMBUS_WRITE_WORD_DATA	0x00400000
// 处理SMBus read_i2c_block_data命令
#define I2C_FUNC_SMBUS_READ_I2C_BLOCK	0x04000000 /* I2C-like block xfer  */
// 处理SMBus write_i2c_block_data命令
#define I2C_FUNC_SMBUS_WRITE_I2C_BLOCK	0x08000000 /* w/ 1-byte reg. addr. */

// 列出所支持的命令集(检测通信方法支持的功能或协议)
static u32 rk3x_i2c_func(struct i2c_adapter *adap)
{

    return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_PROTOCOL_MANGLING;

}

```

### 1.2.5. 添加到I2C总线

I2C核心层为i2c_adapter开放了添加适配器的接口函数i2c_add_adapter()。在注册收尾工作`rk3x_i2c_probe()`函数的最后，调用`i2c_add_adapter()`函数向I2C总线添加i2c_adapter。

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-base.c */
/**
 * i2c_add_adapter - declare i2c adapter, use dynamic bus number
 * @adapter: the adapter to add
 * Context: can sleep
 *
 * This routine is used to declare an I2C adapter when its bus number
 * doesn't matter or when its bus number is specified by an dt alias.
 * Examples of bases when the bus number doesn't matter: I2C adapters
 * dynamically added by USB links or PCI plugin cards.
 *
 * When this returns zero, a new bus number was allocated and stored
 * in adap->nr, and the specified adapter became available for clients.
 * Otherwise, a negative errno value is returned.
 */
int i2c_add_adapter(struct i2c_adapter *adapter)
{

	struct device *dev = &adapter->dev;

	int id;

    // 存在设备树节点(在rk3x_i2c_probe中赋值)
	if (dev->of_node) {
        // 获得总线号，因为总线驱动可以兼容多个同一平台的I2C控制器。一般会在dts里指定，即静态分配ID号
		id = of_alias_get_id(dev->of_node, "i2c");
        // 如果找到I2C总线号则直接注册
		if (id >= 0) {
			adapter->nr = id;
			return __i2c_add_numbered_adapter(adapter);
		}
	}

	mutex_lock(&core_lock);
    // 为i2c_adapter动态分配ID并绑定
	id = idr_alloc(&i2c_adapter_idr, adapter,
		       __i2c_first_dynamic_bus_num, 0, GFP_KERNEL);
	mutex_unlock(&core_lock);
	if (WARN(id < 0, "couldn't get idr"))
		return id;

	adapter->nr = id;

	return i2c_register_adapter(adapter);

}
EXPORT_SYMBOL(i2c_add_adapter); 

```

`i2c_add_adapter`()函数有两种添加到总线的方式。如果在遍历设备树过程中获得了I2C总线的总线号，那么调用`__i2c_add_numbered_adapter()`静态添加。如果找不到，则需要动态添加，调用`i2c_register_adapter()`注册到I2C总线。

`of_alias_get_id()`函数遍历设备树的alias节点下的设备节点，通过传入的两个参数查找设备树中与adapter匹配的节点。

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/of/base.c */
/**
 * of_alias_get_id - Get alias id for the given device_node
 * @np:		Pointer to the given device_node
 * @stem:	Alias stem of the given device_node
 *
 * The function travels the lookup table to get the alias id for the given
 * device_node and alias stem.  It returns the alias id if found.
 */
int of_alias_get_id(struct device_node *np, const char *stem)
{
	struct alias_prop *app;
	int id = -ENODEV;

	mutex_lock(&of_mutex);
    // 遍历链表aliases_lookup(成员为alias_prop)，逐一对比字符串stem。

	list_for_each_entry(app, &aliases_lookup, link) {
        // 过滤掉dtsi中aliases节点内的非I2C节点
		if (strcmp(app->stem, stem) != 0)
			continue;
        // 如果字符串匹配且找到对应的设备树节点，则说明找到了adapter(I2C控制器)设备节点的ID号
		if (np == app->np) {
			id = app->id;
			break;
		}
	}
	mutex_unlock(&of_mutex);

	return id;
}
EXPORT_SYMBOL_GPL(of_alias_get_id);

```

`__i2c_add_numbered_adapter()`函数将i2c_adapter静态添加到I2C总线，代码部分实际和动态添加非常相似(不过是调用函数时传入的形参不同)。最终也是调用`i2c_register_adapter()`注册到I2C总线。

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-base.c */
/**
 * __i2c_add_numbered_adapter - i2c_add_numbered_adapter where nr is never -1
 * @adap: the adapter to register (with adap->nr initialized)
 * Context: can sleep
 *
 * See i2c_add_numbered_adapter() for details.
 */
static int __i2c_add_numbered_adapter(struct i2c_adapter *adap)
{

	int id;

	mutex_lock(&core_lock);
    // 使id号和adapter结构体按照IDR机制关联起来(IDR用类基树结构构造稀疏数组，以ID为索引来找到对应数组元素，进而找到对应的数据结构指针)
	id = idr_alloc(&i2c_adapter_idr, adap, adap->nr, adap->nr + 1, GFP_KERNEL);
	mutex_unlock(&core_lock);
	if (WARN(id < 0, "couldn't get idr"))
		return id == -ENOSPC ? -EBUSY : id;
    // 注册i2c_adapter
	return i2c_register_adapter(adap);

}



```

i2c_adapter注册总线的核心函数`i2c_register_adapter()`，最重要的任务是将设备树中I2C总线节点下的I2C设备转化成`i2c_client`，以备后续使用。

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-base.c */
static int i2c_register_adapter(struct i2c_adapter *adap)
{
	int res = -EINVAL;

	/* Can't register until after driver model init 得先注册I2C总线才能注册adapter */
	if (WARN_ON(!is_registered)) {
		res = -EAGAIN;
		goto out_list;
	}

	/* Sanity checks 如果adapter没有name和algo算法，则直接返回，无法注册 */
	if (WARN(!adap->name[0], "i2c adapter has no name"))
		goto out_list;

	if (!adap->algo) {
		pr_err("adapter '%s': no algo supplied!\n", adap->name);
		goto out_list;
	}

	if (!adap->lock_ops)
		adap->lock_ops = &i2c_adapter_lock_ops;

	adap->locked_flags = 0;
	rt_mutex_init(&adap->bus_lock);
	rt_mutex_init(&adap->mux_lock);
	mutex_init(&adap->userspace_clients_lock);
	INIT_LIST_HEAD(&adap->userspace_clients);

	/* Set default timeout to 1 second if not already set */
	if (adap->timeout == 0)
		adap->timeout = HZ;

	/* register soft irqs for Host Notify */
	res = i2c_setup_host_notify_irq_domain(adap);
	if (res) {
		pr_err("adapter '%s': can't create Host Notify IRQs (%d)\n",
		       adap->name, res);
		goto out_list;
	}

	dev_set_name(&adap->dev, "i2c-%d", adap->nr);
	adap->dev.bus = &i2c_bus_type;
	adap->dev.type = &i2c_adapter_type;

    /**
	 * 本来这里进去会有调用总线probe的机会，但是由于i2c bus
	 * 没有指定match回调，所以会在中途返回，而且返回的是0
	 */
	res = device_register(&adap->dev);
	if (res) {
		pr_err("adapter '%s': can't register device (%d)\n", adap->name, res);
		goto out_list;
	}

	res = of_i2c_setup_smbus_alert(adap);
	if (res)
		goto out_reg;

	pm_runtime_no_callbacks(&adap->dev);
	pm_suspend_ignore_children(&adap->dev, true);
	pm_runtime_enable(&adap->dev);

	res = i2c_init_recovery(adap);
	if (res == -EPROBE_DEFER)
		goto out_reg;

	dev_dbg(&adap->dev, "adapter [%s] registered\n", adap->name);

#ifdef CONFIG_I2C_COMPAT
	res = class_compat_create_link(i2c_adapter_compat_class, &adap->dev,
				       adap->dev.parent);
	if (res)
		dev_warn(&adap->dev,
			 "Failed to create compatibility class link\n");
#endif

	/* create pre-declared device nodes */
    // 构建从设备的软件抽象i2c_client，并与adapter建立联系
	of_i2c_register_devices(adap);
	i2c_acpi_install_space_handler(adap);
	i2c_acpi_register_devices(adap);

	if (adap->nr < __i2c_first_dynamic_bus_num)
		i2c_scan_static_board_info(adap);

	/* Notify drivers */
	mutex_lock(&core_lock);
	bus_for_each_drv(&i2c_bus_type, NULL, adap, __process_new_adapter);		// 通知I2C总线上已经注册的I2C驱动与新注册的adap进行匹配
	mutex_unlock(&core_lock);

	return 0;

out_reg:
	init_completion(&adap->dev_released);
	device_unregister(&adap->dev);
	wait_for_completion(&adap->dev_released);
out_list:
	mutex_lock(&core_lock);
	idr_remove(&i2c_adapter_idr, adap->nr);
	mutex_unlock(&core_lock);
	return res;
}

```

/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-of.c */
```C++
void of_i2c_register_devices(struct i2c_adapter *adap)
{

	struct device_node *bus, *node;
    // 构建i2c_client
	struct i2c_client *client;

	/* Only register child devices if the adapter has a node pointer set 设备树节点不为空 */
	if (!adap->dev.of_node)
		return;

	dev_dbg(&adap->dev, "of_i2c: walking child nodes\n");

    // 查找设备树节点中名称有直接描述I2C总线的节点，为了缩小查找范围
	bus = of_get_child_by_name(adap->dev.of_node, "i2c-bus");
    // 没找到则从头开始遍历
	if (!bus)
		bus = of_node_get(adap->dev.of_node);

    // 遍历每一个子节点，调用of_i2c_register_device解析设备树节点内容
	for_each_available_child_of_node(bus, node) {
		if (of_node_test_and_set_flag(node, OF_POPULATED))
			continue;

		client = of_i2c_register_device(adap, node);
		if (IS_ERR(client)) {
			dev_err(&adap->dev,
				 "Failed to create I2C device for %pOF\n",
				 node);
			of_node_clear_flag(node, OF_POPULATED);
		}
	}

	of_node_put(bus);

}

```

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/of/base.c */
/**
 *	of_get_child_by_name - Find the child node by name for a given parent
 *	@node:	parent node
 *	@name:	child name to look for.
 *
 *      This function looks for child node for given matching name
 *
 *	Returns a node pointer if found, with refcount incremented, use
 *	of_node_put() on it when done.
 *	Returns NULL if node is not found.
 */
struct device_node *of_get_child_by_name(const struct device_node *node,
				const char *name)
{
	struct device_node *child;

	for_each_child_of_node(node, child)
		if (of_node_name_eq(child, name))
			break;
	return child;
}
EXPORT_SYMBOL(of_get_child_by_name);
```

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-of.c */
static struct i2c_client *of_i2c_register_device(struct i2c_adapter *adap, 

						 struct device_node *node)

{

	struct i2c_client *client;
	struct i2c_board_info info;
	int ret;

	dev_dbg(&adap->dev, "of_i2c: register %pOF\n", node);

	ret = of_i2c_get_board_info(&adap->dev, node, &info);
	if (ret)
		return ERR_PTR(ret);

	client = i2c_new_client_device(adap, &info);
	if (IS_ERR(client))
		dev_err(&adap->dev, "of_i2c: Failure registering %pOF\n", node);

	return client;

}

```

```C++
/* /home/usr/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-of.c */
int of_i2c_get_board_info(struct device *dev, struct device_node *node,
			  struct i2c_board_info *info)
{
	u32 addr;
	int ret;

	memset(info, 0, sizeof(*info));

	if (of_modalias_node(node, info->type, sizeof(info->type)) < 0) {
		dev_err(dev, "of_i2c: modalias failure on %pOF\n", node);
		return -EINVAL;
	}

	ret = of_property_read_u32(node, "reg", &addr);
	if (ret) {
		dev_err(dev, "of_i2c: invalid reg on %pOF\n", node);
		return ret;
	}

	if (addr & I2C_TEN_BIT_ADDRESS) {
		addr &= ~I2C_TEN_BIT_ADDRESS;
		info->flags |= I2C_CLIENT_TEN;
	}

	if (addr & I2C_OWN_SLAVE_ADDRESS) {
		addr &= ~I2C_OWN_SLAVE_ADDRESS;
		info->flags |= I2C_CLIENT_SLAVE;
	}

	info->addr = addr;
	info->of_node = node;
	info->fwnode = of_fwnode_handle(node);

	if (of_property_read_bool(node, "host-notify"))
		info->flags |= I2C_CLIENT_HOST_NOTIFY;

	if (of_get_property(node, "wakeup-source", NULL))
		info->flags |= I2C_CLIENT_WAKE;

	return 0;
}
EXPORT_SYMBOL_GPL(of_i2c_get_board_info);

```

最终`i2c_new_client_device()`函数将设备树中的I2C子节点转换为`i2c_client`

```C++
/* /home/zjn/Documents/OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-core-base.c */
/**
 * i2c_new_client_device - instantiate an i2c device
 * @adap: the adapter managing the device
 * @info: describes one I2C device; bus_num is ignored
 * Context: can sleep
 *
 * Create an i2c device. Binding is handled through driver model
 * probe()/remove() methods.  A driver may be bound to this device when we
 * return from this function, or any later moment (e.g. maybe hotplugging will
 * load the driver module).  This call is not appropriate for use by mainboard
 * initialization logic, which usually runs during an arch_initcall() long
 * before any i2c_adapter could exist.
 *
 * This returns the new i2c client, which may be saved for later use with
 * i2c_unregister_device(); or an ERR_PTR to describe the error.
 */
struct i2c_client *
i2c_new_client_device(struct i2c_adapter *adap, struct i2c_board_info const *info)
{

	struct i2c_client	*client;
	int			status;

	client = kzalloc(sizeof *client, GFP_KERNEL);
	if (!client)
		return ERR_PTR(-ENOMEM);

	client->adapter = adap;

	client->dev.platform_data = info->platform_data;
	client->flags = info->flags;
	client->addr = info->addr;

	client->init_irq = info->irq;
	if (!client->init_irq)
		client->init_irq = i2c_dev_irq_from_resources(info->resources,
							 info->num_resources);

	strlcpy(client->name, info->type, sizeof(client->name));

	status = i2c_check_addr_validity(client->addr, client->flags);
	if (status) {
		dev_err(&adap->dev, "Invalid %d-bit I2C address 0x%02hx\n",
			client->flags & I2C_CLIENT_TEN ? 10 : 7, client->addr);
		goto out_err_silent;
	}

	/* Check for address business */
	status = i2c_check_addr_ex(adap, i2c_encode_flags_to_addr(client));
	if (status)
		dev_err(&adap->dev,
			"%d i2c clients have been registered at 0x%02x",
			status, client->addr);

	client->dev.parent = &client->adapter->dev;
	client->dev.bus = &i2c_bus_type;
	client->dev.type = &i2c_client_type;
	client->dev.of_node = of_node_get(info->of_node);
	client->dev.fwnode = info->fwnode;

	i2c_dev_set_name(adap, client, info, status);

	if (info->properties) {
		status = device_add_properties(&client->dev, info->properties);
		if (status) {
			dev_err(&adap->dev,
				"Failed to add properties to client %s: %d\n",
				client->name, status);
			goto out_err_put_of_node;
		}
	}

	status = device_register(&client->dev);
	if (status)
		goto out_free_props;

	dev_dbg(&adap->dev, "client [%s] registered with bus id %s\n",
		client->name, dev_name(&client->dev));

	return client;

out_free_props:

	if (info->properties)
		device_remove_properties(&client->dev);

out_err_put_of_node:

	of_node_put(info->of_node);

out_err_silent:

	kfree(client);
	return ERR_PTR(status);

}
EXPORT_SYMBOL_GPL(i2c_new_client_device); 

```

## 1.3. I2C设备驱动实现

由本文最开始给出的框架图可知，实现I2C设备驱动通常有两条路径：

### 1.3.1. 将I2C控制器暴露给应用的方式

该方式采用标准的 `file_operations` 字符设备的形式，将 `i2c_adapter` 设备化，在`/dev`目录下创建`i2c-n(n=0, 1, 2...)`设备节点。所实现的驱动可看作是一种" `i2c_driver` 成员函数 + 字符设备驱动"的虚拟驱动，需要由应用层通过 `read()` 、 `write()` 函数根据芯片手册直接对I2C控制器进行配置时序等操作，以实现对从设备的控制。这种方式是把对硬件的具体操作放在应用层去实现，适合用来快速测试一款I2C设备的功能，或者在 `i2c_driver` 工作不正常的时候排查具体是设备驱动工作问题还是主机驱动工作问题。并不能作为主流的开发方式。详细可见 `.../OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/i2c-dev.c` 。

```C++

#define I2C_MAJOR	89		/* Device major number		*/
#define MINORBITS	20
#define MINORMASK	((1U << MINORBITS) - 1)
#define I2C_MINORS	MINORMASK

/*
 * module load/unload record keeping
 */

static int __init i2c_dev_init(void)
{
	int res;

	printk(KERN_INFO "i2c /dev entries driver\n");
	// 申请设备号，I2C_MAJOR为89，次设备号为0，I2C_MINORS为1<<20-1，表示次设备号的数量。
	// 就是把这个主设备号对应的次设备号都申请了。
	res = register_chrdev_region(MKDEV(I2C_MAJOR, 0), I2C_MINORS, "i2c");
	if (res)
		goto out;
	// 创建一个同名类，在 /sys/class中可以看到
	i2c_dev_class = class_create(THIS_MODULE, "i2c-dev");
	if (IS_ERR(i2c_dev_class)) {
		res = PTR_ERR(i2c_dev_class);
		goto out_unreg_chrdev;
	}
	i2c_dev_class->dev_groups = i2c_groups;

	/* Keep track of adapters which will be added or removed later */
	// 注册i2c总线的通知函数
	// 参数2详见下
	res = bus_register_notifier(&i2c_bus_type, &i2cdev_notifier);
	if (res)
		goto out_unreg_class;

	/* Bind to already existing adapters right away */
	// 遍历i2c总线上的所有设备，每次都执行第二个参数对应的函数
	i2c_for_each_dev(NULL, i2cdev_attach_adapter);

	return 0;

out_unreg_class:
	class_destroy(i2c_dev_class);
out_unreg_chrdev:
	unregister_chrdev_region(MKDEV(I2C_MAJOR, 0), I2C_MINORS);
out:
	printk(KERN_ERR "%s: Driver Initialisation failed\n", __FILE__);
	return res;
}
```

```C++
static int i2cdev_notifier_call(struct notifier_block *nb, unsigned long action,
			 void *data)
{
	struct device *dev = data;
	// 发生的事件类型
	switch (action) {
	// 此i2c总线下发生添加设备事件
	case BUS_NOTIFY_ADD_DEVICE:
		// 创建设备文件之类的操作
		return i2cdev_attach_adapter(dev, NULL);
	// 此i2c总线下发生删除设备事件
	case BUS_NOTIFY_DEL_DEVICE:
		return i2cdev_detach_adapter(dev, NULL);
	}

	return 0;
}
```

```C++
static int i2cdev_attach_adapter(struct device *dev, void *dummy)
{
	struct i2c_adapter *adap;
	struct i2c_dev *i2c_dev;
	int res;

	// 若设备类型不是i2c适配器，直接返回
	// 也有可能是 i2c_client 设备
	if (dev->type != &i2c_adapter_type)
		return 0;
	// 从i2c设备结构体中获取i2c适配器结构体
	adap = to_i2c_adapter(dev);
	// 分配内存
	i2c_dev = get_free_i2c_dev(adap);
	if (IS_ERR(i2c_dev))
		return PTR_ERR(i2c_dev);
	// 设置文件操作接口
	cdev_init(&i2c_dev->cdev, &i2cdev_fops);
	i2c_dev->cdev.owner = THIS_MODULE;

	device_initialize(&i2c_dev->dev);
	i2c_dev->dev.devt = MKDEV(I2C_MAJOR, adap->nr);
	i2c_dev->dev.class = i2c_dev_class;
	i2c_dev->dev.parent = &adap->dev;
	i2c_dev->dev.release = i2cdev_dev_release;
	dev_set_name(&i2c_dev->dev, "i2c-%d", adap->nr);
	// 注意次设备号为适配器对应的编号，可以自己指定，也可以有系统分配
	// 参数3为此设备哈的数量，此fops只对应此设备号的文件
	res = cdev_device_add(&i2c_dev->cdev, &i2c_dev->dev);
	if (res) {
		put_i2c_dev(i2c_dev, false);
		return res;
	}

	pr_debug("i2c-dev: adapter [%s] registered as minor %d\n",
		 adap->name, adap->nr);
	return 0;
}
```
```C++
static const struct file_operations i2cdev_fops = {
	.owner		= THIS_MODULE,
	.llseek		= no_llseek,
	.read		= i2cdev_read,
	.write		= i2cdev_write,
	.unlocked_ioctl	= i2cdev_ioctl,
	.compat_ioctl	= compat_i2cdev_ioctl,
	.open		= i2cdev_open,
	.release	= i2cdev_release,
};
```
```C++
static int i2cdev_open(struct inode *inode, struct file *file)
{
	// 从inode获取次设备号，就是适配器的编号
	unsigned int minor = iminor(inode);
	struct i2c_client *client;
	struct i2c_adapter *adap;
	// 根据次设备号从i2c总线获取对应的适配器
	adap = i2c_get_adapter(minor);
	if (!adap)
		return -ENODEV;

	/* This creates an anonymous i2c_client, which may later be
	 * pointed to some address using I2C_SLAVE or I2C_SLAVE_FORCE.
	 *
	 * This client is ** NEVER REGISTERED ** with the driver model
	 * or I2C core code!!  It just holds private copies of addressing
	 * information and maybe a PEC flag.
	 */
	// client表示某个具体的i2c设备，为其分配内存
	client = kzalloc(sizeof(*client), GFP_KERNEL);
	if (!client) {
		i2c_put_adapter(adap);
		return -ENOMEM;
	}
	// 设置具体的i2c设备的名字
	snprintf(client->name, I2C_NAME_SIZE, "i2c-dev %d", adap->nr);
	// 设置具体的i2c设备归属的适配器
	client->adapter = adap;
	// 以后可以通过file的此成员获取client指针
	file->private_data = client;

	return 0;
}
```
```C++

/*
 * After opening an instance of this character special file, a file
 * descriptor starts out associated only with an i2c_adapter (and bus).
 *
 * Using the I2C_RDWR ioctl(), you can then *immediately* issue i2c_msg
 * traffic to any devices on the bus used by that adapter.  That's because
 * the i2c_msg vectors embed all the addressing information they need, and
 * are submitted directly to an i2c_adapter.  However, SMBus-only adapters
 * don't support that interface.
 *
 * To use read()/write() system calls on that file descriptor, or to use
 * SMBus interfaces (and work with SMBus-only hosts!), you must first issue
 * an I2C_SLAVE (or I2C_SLAVE_FORCE) ioctl.  That configures an anonymous
 * (never registered) i2c_client so it holds the addressing information
 * needed by those system calls and by this SMBus interface.
 */

static ssize_t i2cdev_read(struct file *file, char __user *buf, size_t count,
		loff_t *offset)
{
	char *tmp;
	int ret;

	struct i2c_client *client = file->private_data;

	if (count > 8192)
		count = 8192;
	// 分配内存，用于接收消息
	tmp = kzalloc(count, GFP_KERNEL);
	if (tmp == NULL)
		return -ENOMEM;

	pr_debug("i2c-dev: i2c-%d reading %zu bytes.\n",
		iminor(file_inode(file)), count);
	// 核心函数，接受一个i2c消息
	ret = i2c_master_recv(client, tmp, count);
	if (ret >= 0)
		if (copy_to_user(buf, tmp, ret))
			ret = -EFAULT;
	kfree(tmp);
	return ret;
}

static ssize_t i2cdev_write(struct file *file, const char __user *buf,
		size_t count, loff_t *offset)
{
	int ret;
	char *tmp;
	struct i2c_client *client = file->private_data;

	if (count > 8192)
		count = 8192;
	// 把用户空间的buf拷贝内核空间的tmp
	tmp = memdup_user(buf, count);
	if (IS_ERR(tmp))
		return PTR_ERR(tmp);

	pr_debug("i2c-dev: i2c-%d writing %zu bytes.\n",
		iminor(file_inode(file)), count);
	// 核心函数，发送一个i2c消息
	ret = i2c_master_send(client, tmp, count);
	kfree(tmp);
	return ret;
}
```

```C++
/**
 * i2c_master_send - issue a single I2C message in master transmit mode
 * @client: Handle to slave device
 * @buf: Data that will be written to the slave
 * @count: How many bytes to write, must be less than 64k since msg.len is u16
 *
 * Returns negative errno, or else the number of bytes written.
 */
static inline int i2c_master_send(const struct i2c_client *client,
				  const char *buf, int count)
{
	return i2c_transfer_buffer_flags(client, (char *)buf, count, 0);
};

/**
 * i2c_master_recv - issue a single I2C message in master receive mode
 * @client: Handle to slave device
 * @buf: Where to store data read from slave
 * @count: How many bytes to read, must be less than 64k since msg.len is u16
 *
 * Returns negative errno, or else the number of bytes read.
 */
static inline int i2c_master_recv(const struct i2c_client *client,
				  char *buf, int count)
{
	return i2c_transfer_buffer_flags(client, buf, count, I2C_M_RD);
};
```

```C++

/**
 * i2c_transfer - execute a single or combined I2C message
 * @adap: Handle to I2C bus
 * @msgs: One or more messages to execute before STOP is issued to
 *	terminate the operation; each message begins with a START.
 * @num: Number of messages to be executed.
 *
 * Returns negative errno, else the number of messages executed.
 *
 * Note that there is no requirement that each message be sent to
 * the same slave address, although that is the most common model.
 */
int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
{
	int ret;

	if (!adap->algo->master_xfer) {
		dev_dbg(&adap->dev, "I2C level transfers not supported\n");
		return -EOPNOTSUPP;
	}

	/* REVISIT the fault reporting model here is weak:
	 *
	 *  - When we get an error after receiving N bytes from a slave,
	 *    there is no way to report "N".
	 *
	 *  - When we get a NAK after transmitting N bytes to a slave,
	 *    there is no way to report "N" ... or to let the master
	 *    continue executing the rest of this combined message, if
	 *    that's the appropriate response.
	 *
	 *  - When for example "num" is two and we successfully complete
	 *    the first message but get an error part way through the
	 *    second, it's unclear whether that should be reported as
	 *    one (discarding status on the second message) or errno
	 *    (discarding status on the first one).
	 */
	ret = __i2c_lock_bus_helper(adap);
	if (ret)
		return ret;

	ret = __i2c_transfer(adap, msgs, num);
	i2c_unlock_bus(adap, I2C_LOCK_SEGMENT);

	return ret;
}
EXPORT_SYMBOL(i2c_transfer);


/**
 * i2c_transfer_buffer_flags - issue a single I2C message transferring data
 *			       to/from a buffer
 * @client: Handle to slave device
 * @buf: Where the data is stored
 * @count: How many bytes to transfer, must be less than 64k since msg.len is u16
 * @flags: The flags to be used for the message, e.g. I2C_M_RD for reads
 *
 * Returns negative errno, or else the number of bytes transferred.
 */
int i2c_transfer_buffer_flags(const struct i2c_client *client, char *buf,
			      int count, u16 flags)
{
	int ret;
	// 传入参数构建消息结构体
	struct i2c_msg msg = {
		.addr = client->addr,
		.flags = flags | (client->flags & I2C_M_TEN),
		.len = count,
		.buf = buf,
	};

	ret = i2c_transfer(client->adapter, &msg, 1);

	/*
	 * If everything went ok (i.e. 1 msg transferred), return #bytes
	 * transferred, else error code.
	 */
	return (ret == 1) ? count : ret;
}
EXPORT_SYMBOL(i2c_transfer_buffer_flags);
```

### 1.3.2. 将I2C控制器抽象成公共驱动的方式

该方式是把所有代码都放在驱动层实现，直接向应用层提供最终结果，即应用层甚至可以不知道I2C的存在。例如电容式触摸屏驱动直接向应用层提供 `/dev/input/eventn` 的操作接口，接收上报到应用层的输入事件。而不需要直到具体是怎么上报的，甚至应用层不知道触摸屏是使用I2C总线和主机进行数据交互的。

rk开发板用的触摸屏是汇顶科技的gt1x型电容式触摸屏，驱动代码位于/driver/input/touchscreen/gt1x/gt1x.c，电容触摸屏通过IIC总线与SOC进行通信，利用其自带的触摸IC完成坐标计算后通过IIC将坐标信息传输给SOC，坐标的计算过程不需要SOC的参与，从这个角度上来说，电容触摸屏就是一个挂载到SOC上的IIC slave设备，与通常所说的Sensor是一样的性质。
```C++
/**
 * gt1x_ts_init - Driver Install function.
 * Return   0---succeed.
 */
static int __init gt1x_ts_init(void)
{
	GTP_DEBUG_FUNC();
	GTP_DEBUG("GTP driver installing...");

	return i2c_add_driver(&gt1x_ts_driver);
}
```
```C++
/**
 * gt1x_ts_probe -   I2c probe.
 * @client: i2c device struct.
 * @id: device id.
 * Return  0: succeed, -1: failed.
 */
static int gt1x_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
{
	s32 ret = -1;
#if GTP_AUTO_UPDATE
	struct task_struct *thread = NULL;
#endif
	/*do NOT remove these logs*/
	GTP_INFO("GTP Driver Version: %s", GTP_DRIVER_VERSION);
	GTP_INFO("GTP I2C Address: 0x%02x", client->addr);

	gt1x_i2c_client = client;
	spin_lock_init(&irq_lock);
	
	// 检查i2c适配器的能力
	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
		GTP_ERROR("I2C check functionality failed.");
		return -ENODEV;
	}

#ifdef GTP_CONFIG_OF	/* device tree support */
	// 解析设备树
	if (client->dev.of_node) {
		ret = gt1x_parse_dt(&client->dev);
		if (ret)
			return ret;
	}
#endif
 	// 申请GPIO端口
	ret = gt1x_request_io_port();
	if (ret < 0) {
		GTP_ERROR("GTP request IO port failed.");
		return ret;
	}
	// 触摸IC初始化
	ret = gt1x_init();
	if (ret != 0) {
		GTP_ERROR("GTP init failed!!!");
		return ret;
	}

	gt1x_wq = create_singlethread_workqueue("gt1x_wq");
	if (!gt1x_wq) {
		GTP_ERROR("Creat workqueue failed.");
		return -ENOMEM;
	}

	INIT_WORK(&gt1x_work, gt1x_ts_work_func);

	ret = gt1x_request_input_dev();
	if (ret < 0) {
		GTP_ERROR("GTP request input dev failed");
	}

	ret = gt1x_request_irq();
	if (ret < 0) {
		GTP_DEBUG("GTP works in polling mode.");
	} else {
		GTP_DEBUG("GTP works in interrupt mode.");
	}

#if GTP_GESTURE_WAKEUP
	enable_irq_wake(client->irq);
#endif

	gt1x_irq_enable();

#if GTP_ESD_PROTECT
	/*must before auto update*/
	gt1x_init_esd_protect();
	gt1x_esd_switch(SWITCH_ON);
#endif

#if GTP_AUTO_UPDATE
	thread = kthread_run(gt1x_auto_update_proc, (void *)NULL, "gt1x_auto_update");
	if (IS_ERR(thread)) {
		ret = PTR_ERR(thread);
		GTP_ERROR("Failed to create auto-update thread: %d.", ret);
	}
#endif
	gt1x_register_powermanger();
	return 0;
}

```

```C++
/**
 * gt1x_parse_dt - parse platform infomation form devices tree.
 */
static int gt1x_parse_dt(struct device *dev)
{
	struct device_node *np;
	const char *tp_type;
#ifdef CONFIG_PM
	struct device_node *root;
	const char *machine_compatible;
#endif

	if (!dev)
		return -ENODEV;

	np = dev->of_node;

	if (!of_property_read_string(np, "goodix,ic_type", &tp_type)) {
		GTP_INFO("GTP ic_type: %s", tp_type);

		if (strstr(tp_type, "gt5688"))
			gt1x_gt5688 = true;
	}
	// 根据NAME获取GPIO
	gt1x_int_gpio = of_get_named_gpio(np, "goodix,irq-gpio", 0);
	//根据NAME获取GPIO
	gt1x_rst_gpio = of_get_named_gpio(np, "goodix,rst-gpio", 0);
	// 判断上述两个GPIO口是否可用
	if (!gpio_is_valid(gt1x_int_gpio) || !gpio_is_valid(gt1x_rst_gpio)) {
		GTP_ERROR("Invalid GPIO, irq-gpio:%d, rst-gpio:%d",
				gt1x_int_gpio, gt1x_rst_gpio);
		return -EINVAL;
	}

	vdd_ana = devm_regulator_get_optional(dev, "vdd_ana");
	if (PTR_ERR(vdd_ana) == -ENODEV) {
		GTP_ERROR("vdd_ana not specified, fallback to power-supply");
		vdd_ana = devm_regulator_get_optional(dev, "power");
		if (PTR_ERR(vdd_ana) == -ENODEV) {
			GTP_ERROR("power not specified, ignore power ctrl");
			vdd_ana = NULL;
		}
	}
	if (IS_ERR(vdd_ana)) {
		GTP_ERROR("regulator get of vdd_ana/power-supply failed");
		return PTR_ERR(vdd_ana);
	}

	gt1x_ics_slot_report = of_property_read_bool(dev->of_node, "gtp_ics_slot_report");
#ifdef CONFIG_PM
	root = of_find_node_by_path("/");
	if (root) {
		machine_compatible = of_get_property(root, "compatible", NULL);
		of_node_put(root);
		if (strstr(machine_compatible, "linux"))
			dev->driver->pm = &gt1x_ts_pm_ops;
	}
#endif

	return 0;
}

```

```C++

s32 gt1x_init(void)
{
	s32 ret = -1;
	s32 retry = 0;
	u8 reg_val[1];

	/* power on */
	gt1x_power_switch(SWITCH_ON);

	while (retry++ < 5) {
		gt1x_init_failed = 0;
		/* reset ic */
		ret = gt1x_reset_guitar();	// reset IC
		if (ret != 0) {
			GTP_ERROR("Reset guitar failed!");
			continue;
		}

		/* check main system firmware */
		ret = gt1x_i2c_read_dbl_check(GTP_REG_FW_CHK_MAINSYS, reg_val, 1);
		if (ret != 0) {
			continue;
		} else if (reg_val[0] != 0xBE) {
			GTP_ERROR("Check main system not pass[0x%2X].", reg_val[0]);
			gt1x_init_failed = 1;
		}

#if !GTP_AUTO_UPDATE
		/* debug info  */
		ret = gt1x_i2c_read_dbl_check(GTP_REG_FW_CHK_SUBSYS, reg_val, 1);	// IIC读写测试，检查IC是否初始化成功
		if (!ret && reg_val[0] == 0xAA) {
			GTP_ERROR("Check subsystem not pass[0x%2X].", reg_val[0]);
		}
#endif
		break;
	}

	/* if the initialization fails, set default setting */
	ret |= gt1x_init_failed;	
	// 判断IC是否初始化成功，如果没有使用默认配置
	if (ret) {
		GTP_ERROR("Init failed, use default setting");
		gt1x_abs_x_max = GTP_MAX_WIDTH;
		gt1x_abs_y_max = GTP_MAX_HEIGHT;
		gt1x_int_type = GTP_INT_TRIGGER;
		gt1x_wakeup_level = GTP_WAKEUP_LEVEL;
	}

	/* get chip type */
	// 获取触摸IC的芯片类型：GT1X 、GT2X，对于不同的芯片类型会有不同的同步方式
	ret = gt1x_get_chip_type();
	if (ret != 0) {
		GTP_ERROR("Get chip type failed!");
	}

	/* read version information */
	ret = gt1x_read_version(&gt1x_version);
	if (ret != 0) {
		GTP_ERROR("Get verision failed!");
	}

	/* init and send configs */
	// 配置驱动IC，初始化完成后不可以再调用该函数
	ret = gt1x_init_panel();
	if (ret != 0) {
		GTP_ERROR("Init panel failed.");
	}

	gt1x_workqueue = create_singlethread_workqueue("gt1x_workthread");
	if (gt1x_workqueue == NULL) {
		GTP_ERROR("Create workqueue failed!");
	}

	/* init auxiliary  node and functions */
#if GTP_DEBUG_NODE
	gt1x_init_debug_node();
#endif

#if GTP_CREATE_WR_NODE
	gt1x_init_tool_node();
#endif

#if GTP_GESTURE_WAKEUP || GTP_HOTKNOT
	gt1x_init_node();
#endif

#if GTP_PROXIMITY
	gt1x_ps_init();
#endif

#if GTP_CHARGER_SWITCH
	gt1x_init_charger();
	gt1x_charger_config(1);
	gt1x_charger_switch(SWITCH_ON);
#endif

#if GTP_SMART_COVER
	gt1x_smart_cover_init();
#endif

#if GTP_WITH_STYLUS
	gt1x_pen_init();
#endif

	return ret;
}

```

gt1x_ts_probe 函数完成了触摸IC的初始化、以及中断事件的初始化，当中断发生时，调用中断处理函数（中断处理函数的上半部分，触摸中断事件需要处理的信息较多，不能全部放到中断处理函数当中去，这里通过工作队列实现了将中断处理分为上下两个部分，在中断处理函数的上半部分调用了queue_work 将中断需要处理的信息作为任务提交到了工作队列），显然这个工作队列也是在probe中完成的初始化以及创建一个专用的内核线程来执行提交到工作队列中的函数gt1x_ts_work_func。
分析到这里，我们可以完整的总结出一次input 事件上报的链路了：

触摸屏IC初始化完成->手指点击触摸屏->引发一次中断->gt1x_ts_irq_handler->queue_work(gt1x_wq, >1x_work)->gt1x_ts_work_func->gt1x_touch_event_handler->gt1x_touch_down->input_report_abs->input_event->input_handle_event->input_pass_event->handler.event->evdev_event->evdev_events->evedv_pass_values