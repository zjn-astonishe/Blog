---
title: C_C++基础知识 1
date: 2022-03-12 23:56:53 +0800
categories: C/C++
tags: [C/C++面经, C/C++基础知识]
mathjax: true
---

# C_C++基础知识 1

## C和C++中某些概念的异同

### new和malloc的区别
- `new`、`delete`是C++独有的**操作符**，而`malloc`和`free`是C/C++中的标准库函数。
  - 使用new创建对象在分配内存的时候会调用对象的构造函数，同时完成对对象的初始化(delete在回收内存的时候也会调用对象的析构函数)。malloc和free是库函数，不在编译器控制范围之内(外部链接)，所以不能够自动调用构造函数和析构函数。
    - malloc只是单纯为变量分配内存，free也只是释放变量内存。
  - C++允许重载new/delete操作符，而malloc和delte是函数，不能重载。
    > 允许重载的是operator new和operator delete，通过malloc和free来实现的。只用来分配所要求的空间，不调用相关对象的构造函数。
    > 
    > 当无法满足所要求分配的空间时，如果有new_handler，则调用new_handler，否则执行bad_alloc异常或者返回0。
    > 
    >重载时，返回类型必须时void*，第一个形参类型必须为分配空间的大小(字节)，类型size_t，后面可以带有其他形参。
- new返回的是指定类型的指针，malloc返回的是`void*`类型(需要强行将其转换为实际类型的指针)。
- malloc需要指定好要申请的内存的大小。
- new内存分配失败的时候，会抛出`bad_alloc`异常，malloc分配内存失败返回NULL。
- 内存区域
  - 凡是通过new操作符进行内存申请得到的内存都属于自由存储区(C++基于new操作符的一个抽象概念)。new操作符从自由存储区上为对象动态分配内存空间。
  - 堆是操作系统的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配。malloc函数从堆上动态分配内存。

#### malloc的底层实现
> ![Linux内核空间模型](https://github.com/zjn-astonishe/image/blob/main/C%E3%80%81C++/Linux%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E6%A8%A1%E5%9E%8B.png?raw=true)
> 
> Linux维护着一个名为`program break`的指针，它指向堆空间的某个地址，从堆的起始地址到该指针之间的地址空间为映射好的，可供进程访问。
> 
> 而从该指针往上，是未映射的地址空间，访问这段空间会导致程序报错。用malloc进行内存分配就是从该指针往上进行的。
> 
> ![堆内部机制](https://github.com/zjn-astonishe/image/blob/main/C%E3%80%81C++/%E5%A0%86%E5%86%85%E9%83%A8%E6%9C%BA%E5%88%B6.png?raw=true)
> 
> malloc函数的实质是有一个将可用内存块连接的空闲链表。调用malloc()函数的时候，沿着空闲链表寻找足以满足用户请求的内存块。然后，将该内存块一分为二：一块与用户申请大小相等，传给用户使用；另一块为剩余内存，返回连接到空闲链表。
> 
> 如果用户申请一个大的内存片段，空闲链表上没有可以满足用户要求的片段的时候，malloc函数会请求延时，并开始将空闲链表上的内存片段进行整理合并，直到有符合用户要求的内存片段为止。

#### 在1G内存的计算机中能否运行malloc(1.2G)？
- 有可能申请到1.2G内存。
- 应用程序通过malloc函数可以向程序的虚拟空间申请一块虚拟地址空间，与物理内存没有直接关系，得到的是在虚拟地址空间中的地址，之后程序运行所提供的物理内存是由操作系统完成的。
- 当前Windows环境可申请的最大空间超过1.9G，具体数值会受到操作系统版本、程序本身的大小、用到的动态/共享库数量、大小、程序栈数量、大小等的影响，甚至每次运行的结果都可能存在差异(有些操作系统使用了随即地址分布技术，使进程的堆空间变小)。
- $1.2=1.2*2^{30}$Byte，数值在malloc函数参数类型的范围内。因此是可能能申请到的。
- 即malloc函数调用申请超过机器物理内存大小的内存块是有可能成功的(存储时以硬盘空间作为虚拟内存)。

### 指针和引用的异同

#### 相同
- 指针和引用都是地址概念。
- 从内存分配上看，指针和引用都占用内存。
  - 程序为指针变量分配内存区域(32位系统即地址可能为32位的值，指针变量存储的是指向某变量的地址，大约要32位的空间，即4个字节)
  - 引用本质是指针常量，所以占用的大小也是4个字节(除非编译器进行优化)所指向的对象是不能改变的，但指向对象的值是可以改变的。‘

#### 区别
- 指针是一个实体，引用只是别名。
- 指针的自增是指向内存地址的增加，引用的自增是引用的值的增加。
- 引用使用时不需要解引用(*)，指针使用时需要。
- 引用只能在定义时被初始化一次，之后不可变。指针可变。
- 引用不能为空，指针可以为空。
- 引用没有const，指针有const
  ```C++
    //cost修饰的是指针变量a，即指针指向的整型值可以改变，但是指针指向地址不能变。指针常量
    int* const a;   //从后往前看，const修饰的是p，所以指针p本身不可变
    //cost修饰的是整型数*a，即指针可以改变指向地址，但不能改变指向位置的对应值。常量指针
    const int* a;   //从后往前看，const修饰的是*p，所以指针p指向的数值不可变
    // 没有int& const a
    double r;
    const int &a = r; //正确 性质1：不可通过常量引用a来改变r
    const int &a = 10;//正确 性质2：常量引用可以直接引用具体数值
  ```
- 没有指向引用的指针，但是有指针的引用
  - 没有指向引用的指针，因为指针是本质上是指向某一块内存空间的，而引用只是一个变量的别名，本身是没有地址的，如果要创建一个指针指向某个引用，那么其实指向的是这个引用所引用的对象
  ```C++
  // 指向引用的指针实际指向引用所引用的对象
  int v = 1;
  int &ri = v; //整型变量v的引用
  int *p = &ri; //指针p其实指向的是变量v
  // 指针的引用
  int v = 1;
  int *p = &v;
  int *&rp = p;  // 定义了一个指向指针p的引用rp，即rp作为指针p的别名。
  cout << *rp << endl; // 即相当于输出*p。
  ```
- `sizeof()`得到的引用的大小是所指向变量(对象)的大小，而得到的指针的大小是其本身大小(32位4字节)。

#### 指针与引用相互转换
- 指针转引用
  - 指针用解引用`*`可转换成对象，可以用在引用参数当中。
- 引用转指针
  - 引用类型的对象用取地址`&`就能获得指针。
```C++
#include <iostream>
using namespace std;
void func(int &va);
int main()
{
    int a = 2022;
	int &b = a;
	int *pA = &b;
	cout << "*pA: " << *pA << endl;
	func(*pA);
	return 0;
}
void func(int &va)
{
	cout << "va: " << va << endl;
}
```

### struct和class的区别
- 在C++中struct和class意义基本是一样的。
- struct里面默认的访问控制是public，而class中的默认访问控制是private。
```C++
#include <iostream>
using namespace std;
class A{
public:         // 必须加public，不然默认是private
	int a;
	A(int a)
	{
		this->a = a;
	}
};
int main()
{
	A a1(1);
	cout << a1.a << endl;
    cout << "Hello, world!" << endl;
    return 0;
}
```

### const常量和#define的区别
- 从定义常量是否有类型来看
  - #define定义的常量是没有类型的，所给出的是一个立即数，编译器只是把所定义的常量值与所定义的常量名字联系起来。#define定义的宏变量在预处理阶段就进行替换，在程序中使用到该常量的地方都要进行拷贝替换。所以如果不进行类型安全检查，可能会产生意想不到的错误。
  - const定义的常量是有类型的，编译时会进行类型检查，存放在内存的静态区域中，在编译时确定其值。在程序运行过程中，
- 从消耗的内存大小来看
  - const变量只有一个拷贝，而#define所定义的宏变量却有多个拷贝，所以宏定义在程序运行过程中所消耗的内存要比const大得多。
- 从是否可以用指针变量去指向来看
  - 用#define定义的常量是不可以用指针变量去指向的
  - 用const定义的常量是可以用指针去指向常量地址的。
- 从是否可以定义函数来看
  - 用#define可以定义一些简单的函数(宏替换只是替换，不做计算和表达式求解)
  - 用const是不可以定义函数的。
- 从作用范围来看
  - #define宏定义的作用范围仅限于当前文件。
  - 默认状态下，const常量只在文件内有效，当多个文件中出现同名的const变量时，等同于在不同文件中分别定义了独立的变量。
    - 如果想在多个文件之间共享const常量，必须在变量定义之前添加extern关键字。(在声明和定义时都要加)