---
title: C_C++基础知识 2
date: 2022-03-13 15:26:05 +0800
categories: C/C++
tags: [C/C++面经, C/C++基础知识]
mathjax: true
---

# C_C++基础知识 2

## C/C++中的存储相关

### c/c++中变量的作用域
- 作用域即一个变量的有效范围、生命周期。
- 变量的有效作用域由变量所在的最近一对括号确定。
  - 从它的定义点开始，到和定义变量之前最邻近的开括号配对的第一个闭括号。
- 全局变量
  - 在所有函数体的外部定义。
  - 程序的所在部分(甚至其他文件)都可以使用，全局变量不受作用域的影响，生命周期从定义开始一直到程序结束。
  - 如果在一个文件中使用extern关键字来声明另一个文件中存在的全局变量，那么这个文件可以使用该全局变量。
- 局部变量
  - 局限于一个函数的变量，通常被称为自动变量(在进入作用域时自动生成，离开作用域时自动消失)。
  - 函数中定义局部变量在函数中作用域结束时消失。当再次调用这个函数时，会重新创建变量的存储空间，其值会被重新初始化。
  - 局部变量默认为auto。
- 寄存器变量
  - 一种局部变量。关键字register告诉编译器"尽可能快地访问这个变量"。加快访问速度取决于现实，通常是在寄存器中放置变量来实现(不保证一定实现，只是暗示编译器)。
  - register变量是有限制的：
    - 不可能得到或计算register变量的地址; 
    - register变量只能在一个块中声明(不可能有全局的或静态的register变量，不过c语言里register关键字可以在全局中定义变量)。
    - 可以在一个函数中(即在参数表中)使用register变量作为一个形式参数。
  - 要避免使用关键字register。
- 静态变量
  - 如果想使局部变量的值在程序的整个生命期里仍然存在，可以定义函数的局部变量为static(静态的)，并给它一个初始化。
  - 静态局部变量只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在。
  - 静态局部变量和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只在定义自己的函数体内始终可见。
  - static局部变量的优点是在函数范围之外它是不可用的，所以它不可能被轻易改变。这会使错误局部化，更容易被发现。
  - 同样存在静态全局变量，具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。
- 外部变量
  - extern告诉编译器存在着一个变量和函数，即使编译器在当前的文件中没有看到它。这个变量或函数可能在一个文件或者在当前文件的后面定义。
- const常量
  - const告诉编译器这个名字表示常量，不管是内部的还是用户定义的数据类型都可以定义为const。如果定义了某对象为常量，然后试图改变它，编译器将会产生错误。在C++中一个const必须有初始值。
- volatile变量
  - 限定词volatile则告诉编译器“不知道何时变化”，防止编译器依据变量的稳定性作任何优化。

### C语言检索内存情况，内存分配的方式
- 检索内存：对某段内存遍历搜索。
- 内存分配：
  - 从静态区域分配，内存在程序编译的时候已经分配好，这块内存在程序的整个运行期间都存在(全局变量，static静态变量)。
  - 在栈上创建，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元会被自动释放。栈内存分配运算内置于处理器的指令集，效率很高，但容量有限。
  - 从堆上分配，动态分配内存。用malloc或new申请指定大小的内存，在程序中free或delete释放申请的内存。动态内存的生存周期由程序员决定，所以非常灵活，但是必须要注意回收内存，否则会导致内存泄漏，频繁分配和释放不同大小的堆空间会产生堆内碎块。

### 函数参数压栈顺序，关于`__stdcall`和`__cdecl`调用方式的理解
- `__stdcall`和`__cdecl`都是函数调用约定关键字。
- __stdcall：StandardCall的缩写，是C++的标准调用方式，参数由右向左压入堆栈，由调用者负责把参数压入栈，最后由被调用者负责清除栈的内容。
- __cdecl：C Declaration的缩写，表明C语言默认的函数调用方式，参数也是由右向左压入堆栈，由调用者负责把参数压入栈，最后也由调用者负责清除栈的内容。且支持多输入不同数量的参数(printf)。
  - 因为被调用者不知道有多少参入被压入堆栈，所以无法清楚栈中的内容。

### 重写memcpy函数
- 重写memcpy()需要考虑地址重叠的情况。
```C++
#include <iostream>
#include <cstring>
using namespace std;
int main()
{
	int a[] = {1, 2, 3, 4, 5};
	int b[] = {1, 2, 3, 4, 5};
	int i;
  // memcpy(des, source, bytes)
	memcpy(&a[0], &a[2], 12);   // 由低地址向高地址，从前往后拷贝。
	memcpy(&b[2], &b[0], 12);   // 由高地址向低地址，从后往前拷贝。
    cout << "case 1: ";
	for(i = 0; i < 4; i++)
		cout << a[i] << " ";
	cout << a[i] << endl;
	cout << "case 2: ";
	for(i = 0; i < 4; i++)
		cout << b[i] << " ";
	cout << b[i] << endl;
    return 0;
}
```
- 代码
```C++
void *Memcpy(void *dst, const void *src, size_t1 size)
{
    char *psrc;  // 源地址
    char *pdst;  // 目标地址
    if(NULL == dst || NULL == src)
    {
        return NULL;
    }
    // 源地址在前，且会出现地址重叠。对应上述情况2，需要自后向前拷贝
    if((src < dst) && (char *)src + size > (char *)dst)  
    {
        psrc = (char *)src + size - 1;
        pdst = (char *)dst + size - 1;
        while(size--)
        {
            *pdst-- = *psrc--;
        }
    }
    // 源地址在后，且会出现地址重叠情况，对应上述第一种情况，直接逐个拷贝*pdst++ = *psrc++即可
    // 当然也包括无地址重叠的情况。
    else   
    {
        psrc = (char *)src;
        pdst = (char *)dst;
        while(size--)
        {
            *pdst++ = *psrc++;
        }
    }
    return dst;
}
```

### 数组存放
- 固定数组在函数体内分配(非静态)是存放在栈中。
- 固定数组是全局变量或静态局部数组存放在全局数据中。
- 固定数组在类中分配是存放在堆中。
- 动态数组(malloc、new)一定是存放在堆中。

### static的用法
- 在C语言中，static的作用是改变变量的生命周期或者改变变量的作用域。
- static局部变量：
  - 局部变量为动态存储，即指令执行到定义处才进行内存分配，将一个变量声明为函数的局部变量，使其变为静态存储方式(静态数据区)，那么这个局部变量在函数执行完成之后不会被释放，而是继续保留在内存中。
- static全局变量
  - 对变量的链接方式产生影响。在编译时就分配内存，只在本文件内部有效，而其他文件不可链接或引用该变量。
- static函数(静态函数)
  - 对函数的链接方式产生影响。使得函数只在本文件内部有效，对其他文件是不可见的，即不会受到其他文件的同名函数产生的干扰，另外也是对函数本身一种保护机制。如果其他文件想要引用本地函数，则要在函数定义时用关键字`extern`，表示该函数时外部函数，可供其他文件调用，而不是用`static`。
- 类中的static
  - static成员变量
    - 表示这个成员变量为全类所共有，对类的所有对象只有一份拷贝，可以借助类名直接访问。
  - static成员函数
    - 表示这个函数为全类所共有，而且只能访问静态成员变量，因为这个函数不接收this指针。
    - 静态成员函数属于类，独立于对象而存在，如果没有对象，那么静态成员函数不能访问非静态的成员变量和调用非静态的成员函数。

### const的用法
- const是常量修饰符，const变量必须在声明的时候就进行初始化。
- const修饰常量
  - 定义时就初始化，以后不能更改。
- const修饰形参
  - 形参在函数里不能被更改。
- const修饰类成员函数
  - 如果要声明一个const类型的类成员函数，只需要在成员函数列表后加上关键字const；在类体之外定义const成员函数时，还必须加上const关键字。
  - const修饰的不是形参a和b；const修饰的是属性this->a和this->b。与const所写的位置无关。本质上，const指针修饰的是被隐藏的this指针所指向的内存空间，修饰的是this指针。
  - 该函数对成员变量只能进行只读操作，即不能修改成员变量的数值。(值得注意的是，如果类中存在指针类型的数据成员即便是const函数只能保证不修改该指针的值，并不能保证不修改指针指向的对象。)
  - const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；
  - 非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；但如果只有const成员函数，非const对象是可以调用const成员函数的。当const版本和非const版本的成员函数同时出现时，非const对象调用非const成员函数。
  - 作为一种良好的编程风格，在声明一个成员函数时，若该成员函数并不对数据成员进行修改操作，应尽可能将该成员函数声明为const 成员函数。

### volatile的作用和用法
- volatile的本意是"易变的"。作用是影响编译器的编译结果。
  - 由于访问寄存器要比访问内存单元更快，所以编译器一般都会作减少存取内存的优化，但有可能会读到脏数据。当要求使用volatile声明变量值的时候，编译器对访问该变量的代码就不再进行优化，系统总是重新从它所在的内存读取数据，即使前面的指令刚从该处读取过数据。
- 中断服务程序中修改的供其他程序检测的变量，需要加volatile：
    ```C++
    /**
     * 程序本意希望ISR_2中断产生时，在main函数中调用dosomething函数。
     * 但是由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，
     * 然后每次if判断都只使用该寄存器的"i副本"，导致dosomething函数永远不会被调用。
     * 如果将变量加上volatile修饰，则编译器保证对此变量的读写操作不会被优化。
     */ 
    volatile int i=0;
    int main(void)
    {
        ...
        while (1){
            if (i) 
                dosomething();
        }
    ｝
    /* 中断服务程序 */
    void ISR_2(void)
    {
        i=1;
    }
    ```
- 多任务环境下(多线程)各任务间共享的标志应该加volatile。
- 存储器映射的硬件寄存器通常要加volatile，因为每次读写都可能有不同意义。
    ```C++
    /**
     * 假设要对一个设备进行初始化，此设备的某一个寄存器为0xff800000。
     * 经过编译器优化后，编译器认为前面循环半天都是废话，对最后的结果毫无影响，因为最终只是将output这个指针赋值为9，所以编译器最后给出编译的代码结果相当于只对端口进行了一次赋值为9的操作。
     * 如果对此外部设备进行初始化的过程是必须是像上面代码一样顺序的对其赋值，显然优化过程并不能达到目的。
     */ 
    volatile int  *output = (volatile unsigned  int *)0xff800000;//定义一个IO端口；
    int   init(void)
    {
        int i;
        for(i=0;i< 10;i++){
            *output = i;
        }
    }
    /**
     * 反之如果你不是对此端口反复写操作，而是反复读操作，其结果是一样的，编译器在优化后，也许代码对此地址的读操作只做了一次。
     * 然而从代码角度看是没有任何问题的。这时候就该使用volatile通知编译器这个变量是一个不稳定的，在遇到此变量时候不要优化。
     */
    ```
### extern C
- 如果要在C++中使用C的已编译好的函数模块，为了避免**C++ name mangling**，需要用到`extern "C"`，主要用于动态链接库，使得在C++里到处函数名称与C语言规则一致，方便不同的编译器甚至不同的开发语言调用。
- 当然C++中编译的函数要在C中调用也需要使用extern "C"。
```C++
/**
 * 函数func会被C++编译器改名为int_fun_int，即返回类型_函数名_参数类型。
 * 如果加上extern "C"修饰，则编译器会按照C语言编译器编译为_fun。
 */
int func(int a);
``` 
- C++调用一个C语言编写的.so库时，包含描述.so库中函数的头文件时，应该将对应头文件防止在extern "C"{}中。
- C中引用C++中的全局函数时，C++的头文件需要加extern "C"，而C文件中不能用extern "C"，只能用extern关键字。
- extern可以多次声明，但只有一个定义。(头文件最好只有声明，不要放变量定义，即对变量进行初始化操作等)
- extern在编译的链接阶段起作用。
