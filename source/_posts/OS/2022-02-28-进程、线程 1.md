---
title: 进程、线程 1
date: 2022-02-28 21:34:25 +0800
categories: 操作系统
tag: 进程、线程
mathjax: true
---

# 进程、线程

## 进程线程的基本概念

### 什么是进程、线程(彼此有什么区别)
- 进程是**资源(CPU、内存等)分配**的基本单位，线程是**CPU调度**的基本单位(**程序执行的最小单位**)。
  - 程序运行时，系统会给程序创建一个进程，并分配给予地址空间和其他资源，然后把进程加入到就绪队列中等待CPU执行。
  - 线程是进程的一个执行流，实际上进程不能用来运行代码，真正运行代码的是进程里的线程。
- 一个进程由`PCB`(进程控制块)、数据段、代码段组成
  - 进程一般会先创建出一个主线程，分配给主线程一定的系统资源，让主线程运行起来实现各种功能。主线程里可以创建出多个子线程，多个子线程在同一个进程里，利用进程所拥有的资源合作完成一系列更为复杂的功能。
> C程序中的main函数：
> 
> 一方面作为程序入口，可以被认为是程序的主线程。
> 
> 另一方面系统在执行main函数的时候，main函数又是一个独立的进程，程序员可以在main函数里编写插入创建子进程、子线程的代码。
```C++
#include <iostream>
#include <pthread.h>
#include <unistd.h>
using namespace std;
int g_cnt = 0;  //全局变量
int * thread(void * arg)
{
    int m_cnt = 0;
    m_cnt = 5;
    g_cnt++;
    return 0;
}

int main(void)
{
    int err = 0;
    pthread_t tid;
    int m_cnt = 0;
    err=pthread_create(&tid, NULL, thread, NULL);  //创建子线程
    if (0 != err)   //检验是否创建成功
    {
        cout << "can't creat thread: " << strerror(err)) << endl;
    }
    while(g_cnt == 0)
    {
        usleep(300);   //延迟300毫秒，让子线程运行一会儿
    }
    cout << "g_cnt = " <<  g_cnt << ", m_cnt = " << m_cnt << endl;
    return 0;
}
```
> 在main函数里创建的多个子线程中，每个线程都将有自己的堆栈和局部变量，多个子线程还可以共享同个进程下的所有共享资源(例如全局变量)，因此可以通过创建多个线程来实现并发操作，完成更复杂的任务。
> 
> 在上述代码中，main函数是一个主线程，由它开始执行程序。
> 
> 但同时，main函数也扮演了进程的角色，因为它通过pthread_create函数创建了一个额子线程，用来执行函数thread()。子线程拥有自己的堆栈和局部变量，与主线程共享同一进程下的所有共享资源，如全局变量g_cnt，
> 
> 所以主线程要输出的变量中，
> 
> g_cnt是子线程与主线程共享的全局变量，输出结果为1
> 
> m_cnt是各线程独自拥有的局部变量，子线程m_cnt的改变无法影响要输出的主线程m_cnt的值，输出结果为0

### 多进程、多线程的优点
- 由运行的稳定性来说
  - 多进程更健壮，一个进程停止运行不会影响其他进程，紫禁城停止运行也不会影响主进程的运行，因为进程是资源分配的基本单位，即系统为每个进程分配独立的资源。
  - 多线程更脆弱，一个线程崩溃很可能影响到整个程序，因为线程是CPU调度的基本单位，多个线程都是在一个进程里运行的，其中难免会有一些共享的资源空间。
- 从运行的性能来看
  - 进程的性能大于线程，每个进程都有独立的地址空间和资源
  - 而多个线程是一起共享同个进程的空间和资源，线程存在竞争资源空间的问题，所以在性能方面比不上进程。
- 从系统花销来看
  - 由于进程需要独立的地址空间和资源，因此创建多进程的系统化小要远大于多线程
- 从数据传送来看
  - 多进程通讯因为需要跨越进程边界，因此不适合大量数据的传送，更适合小数据或者密集数据传送
  - 多线程在同一个进程里运行，不需要跨越进程边界，适合各线程间大量数据传送，甚至多线程可以共享同一进程里的共享内存和变量
- 从逻辑控制来看
  - 多进程逻辑控制比多线程复杂，需要与主进程交互，用来合作"做大事"
  - 而多线程通常用来各自"做小事"(虽然其逻辑控制比较简单，但是需要复杂的线程同步和加锁控制等机制实现同步互斥)
- 从增加数量上限来看
  - 进程数量可以通过增加CPU数量的方式来增加
  - 线程数量由进程的空间资源和线程本身栈大小确定，无法通过增加CPU数量增加

### 进程和线程的取舍
- 创建和销毁较频繁的情况使用线程，因为创建和销毁进程的花销较大
- 需要大量数据传送的情况使用线程，多线程切换速度快，且不需要跨进程边界
- 并行操作使用线程(为实现并行的手段)
- 安全稳定的需求使用进程，快速频繁的需求选用线程

### 补充
- 有一类子进程是不需要复制父进程的内存和数据的，单纯为了方便调用外部程序而创建
- 一个播放器框架
> 主线程main函数创建子进程player执行播放视频的代码——调用外部播放器播放视频，创建子线程check监测播放器按钮情况，而main函数执行while(1)死循环。当用户按下播放器的某些按钮如：上一部、下一部时，子线程check会通知主线程main函数，让其再次创建子进程player调用外部播放器播放视频

### 多进程、多线程同步(通讯)的方法
- 进程间的通讯
  - 管道/命名、无名管道：
    - 一个管道实际上就是个**只存在于内存中**的文件，对这个文件的操作要通过两个已经打开的文件进行(管道两端)。但是，管道是一个特殊的文件，即它不属于某一种文件系统，而是一种独立的文件系统，有其自己的数据结构。两个进程结束的时候，管道也会自动消失。
    - 无名管道主要用于父进程与子进程之间，或者两个兄弟进程之间。Linux系统中可以通过系统调用建立起一个单向的通信管道，且这种关系只能由父进程来建立。因此，每个管道都是单向的，当需要双向通信的时候就需要建立起两个管道。管道两端的进程都将该管道看作是一个文件，一个进程负责往管道中写内容，一个进程负责从管道中读取。这种传输遵循先入先出(FIFO)的规则。
    - 命名管道是为了解决无名管道只能用于近亲进程之间通信的缺陷而设计。建立在实际的磁盘戒指或是文件系统中会有自己名字的文件(**不是只在内存**)。任何进程任何时间通过文件名或者路径名都可以与该文件建立联系。
      - 引入新的文件类型——FIFO文件(遵循先进先出的原则)。命名管道一旦建立，之后读写以及关闭操作都与普通管道完全相同。虽然FIFO文件的inode节点在磁盘上，但是仅仅是节点，文件数据还是存在于内存缓冲页面，和无名管道相同。
  - 信号 
    - 进程间传递的消息，软中断
  - 共享内存
  - 消息队列
  - 信号量
    - 用于同步
  - socket
- 线程间的通信
  - 信号量
    - 用于同步，保证程序按照正确的顺序运行
  - 读写锁
  - 条件变量
  - 互斥锁
    - 用于互斥，即保证同一资源不能被同时访问
  - 自旋锁
- 临界区指的是访问公共资源的程序片段，不是通信方式

### 进程的空间模型
- 32位系统中，当系统运行一个程序，就会创建一个进程，系统会为其分配**4G的虚拟地址空间**，其中**0-3G是用户空间**，**3-4G是内核空间**，内核空间是受保护的，用户不能对该空间进行读写操作，否则可能出现段错误。其中栈空间的数据地址增加是往下的(新的数据地址值反而更小)，堆空间的地址增加是往上的。
- 空间模型分析
  - 栈区
    - 由编译器自动分配和释放，存放函数的参数值(形参)、局部变量等，其操作方式类似数据结构的栈，先进后出。
    - 栈的空间有限，堆是很大的自由存储区，程序在编译期对变量和函数分配内存都在栈上进行，程序运行过程中函数调用参数的传递也是在栈上进行
  - 堆区
    - 一般由程序员分配和释放，若程序员不释放，可能会造成内存泄漏，程序结束的时候可能会被操作系统回收，分配方式类似链表，但不是数据结构中的堆。
  - 全局区(静态区)
    - 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在区域`.data`，未初始化的全局变量和未初始化的静态变量存储在相邻的区域`.bss`，程序结束后由系统释放。
  - 文字常量区
    - 常量字符串存储位置，程序结束后由系统释放。
  - 程序代码区(text)
    - 存放函数体的二进制代码。
  - .rodata数据段用于`存放C中的字符串`和`#define定义的常量`
![Linux内核空间模型](https://github.com/zjn-astonishe/image/blob/main/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B/Linux%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E6%A8%A1%E5%9E%8B.png?raw=true)
- 64位操作系统下的虚拟内存空间大小：
  - 地址空间一般是$2^{48}$(256TB)，因为$2^{64}$太大，过大的空间只会造成资源的浪费。
    - 40位标识物理地址(可以找到存储对应物理地址的位置)
    - `0x0000000000000000`~`0x00007fffffffffff`表示用户空间
      - 内核功能模块运行在内核空间。
      - 内核运行在最高权限级别的内核态，可以进行所有操作。
    - `0xFFFF800000000000`~`0xFFFFFFFFFFFFFFFF`表示内核空间
      - 应用程序运行在用户空间。
      - 应用程序运行在较低级别的用户态。

### 进程创建线程数量的决定因素
- 虚拟内存的大小
- 分配给线程的调用栈大小决定

### 进程、线程的状态转换图
- 状态
  - 创建态(new)
    - 一个进程(线程)正在被创建，还没转换到就绪态之前的状态。
  - 就绪态(ready)
    - 一个进程(线程)获得了除CPU时间片之外的一切所需资源，一旦得到CPU时间片即可被CPU调度运行。
  - 运行/执行态(running)
    - 一个进程(线程)得到CPU调度正在处理机上运行时的状态。
  - 睡眠/挂起态(sleep)
    - 由于某些资源暂时不可得到而进入该状态，将进程(线程)挂起，等待唤醒。
  - 阻塞/暂停态(blocked)
    - 一个进程(线程)正在等待某一事件而暂停运行时，如等待某资源成为可用，或等待文件读取完成。
  - 结束/僵尸态(exit)
    - 一个进程(线程)正在从系统中消失时的状态，进程(线程)结束或其他原因导致。
  - 死亡态(die)
    - 进程(线程)生命周期结束，所占用资源归还。

![进程(线程)的一生](https://github.com/zjn-astonishe/image/blob/main/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%80%E7%94%9F.png?raw=true)

> 父进程调用fork()函数创建子进程，此时子进程处于创建态，系统将为进程分配地址和资源，
> 
> 然后将其加入就绪队列，子进程进入就绪态。
> 
> 就绪态的进程得到CPU时间片调度正式运行，进入执行态。在执行态将可能有四种情况发生：
> 1. 时间片耗尽或者被其他进程抢占，将重新进入就绪态，等待下一次CPU时间片。
> 2. 由于某些资源暂时不可得到(如访问文件冲突)进入睡眠态，等待资源可得后再被唤醒，进入就绪态。
> 3. 收到**SIGSTOP/SIGTSTP信号**进入暂停态，指导收到**SIGCONT信号**进入就绪态。
> 4. 进程执行结束，通过内核调用进入僵尸态，等待资源回收。当父进程调用**wait()/waitpid()**后接收结束子进程，该进程进入死亡态。

### 父进程和子进程的关系
- 子进程继承父进程的：
  - 用户号`UIDs`和用户组号`GIDs`
  - 环境`Environment`
  - 堆栈
  - 共享内存
  - 打开文件的描述符
  - 执行时关闭(`Close-on-exec`)标志
  - 信号(`Signal`)控制设定
  - 进程组号
  - 当前工作目录
  - 根目录
  - 文件方式创建屏蔽字
  - 资源限制
  - 控制终端
- 子进程独有的：
  - 地址空间
  - 进程号`PID`
  - 不同的父进程号
  - 自己的文件描述符和目录流的拷贝
  - 子进程不继承父进程的进程正文(text)，数据和其他锁定内存(memory locks)
  - 不继承异步输入和输出
- 父进程调用fork()后，会克隆出一个子进程。但其实是父进程只复制了自己的`PCB块`交给子进程，而代码段，数据段和用户堆栈内存空间是父进程与子进程共享的。只有当子进程在运行中出现写操作时，才会产生中断，为子进程分配内存空间。
  - 也就是说：父子进程肯定共享代码空间，但是数据空间通常是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置(两进程的程序计数器pc值相同，也就是说，子进程是从fork返回处开始执行的)。
  - fork()在创建子进程的时候，有两个返回值：
    - 父进程中的返回值是子进程的进程号(不成功则返回错误)。
    - 子进程中的返回值是0。