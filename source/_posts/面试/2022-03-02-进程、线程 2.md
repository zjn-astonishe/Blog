---
title: 进程、线程 2
date: 2022-03-02 00:43:23 +0800
categories: 操作系统
tag: 进程、线程
mathjax: true
---
# 进程、线程

## CPU上下文

###  特权模式切换
- 用户态和内核态的划分，引出上下文的概念。
- 创建一个进程(如main函数)需要控制一个外部设备时(比如控制LED亮灭)，程序员编写在用户空间的代码通过**系统调用**(操作系统提供给用户空间的接口函数)进入内核空间，由内核继续代表进程运行于内核空间。
- 在系统调用的过程中发生上下文切换：
  1. CPU寄存器里面原来用户态的指令位置，需要先保存起来，接着运行内核态代码。
  2. CPU寄存器需要更新为内核态指令的位置，执行内核态代码。
- 系统调用结束后，CPU寄存器需要恢复原来保存的用户态，然后切换为用户空间。
- 所以一次系统调用的过程，会发生两次的CPU上下文切换
- 但是一般说系统调用是特权模式切换而不是上下文切换。因为没有涉及到虚拟内存等这些进程用户态的资源，也不会切换进程，属于进程之内的上下文切换。

### 进程上下文
- 进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以用户态和内核态的切换不属于进程上下文切换。
- 进程的上下文包含了虚拟内存、栈、全局变量等用户空间的资源，还包含了内核堆栈、寄存器等内核空间的状态，所以进程的上下文切换要比系统调用更多一步——保存该进程的虚拟内存、栈等用户空间的资源。
- 进程上下文切换一般需要几十纳秒到数微秒的CPU时间，当进程上下文切换次数比较多的情况下，将导致CPU耗费大量的时间在寄存器、内核栈即虚拟内存等资源的保存和恢复上。
- 另外，Linux通过TLB快表来管理虚拟内存到物理内存的映射关系，当虚拟内存更新之后，需要刷新缓存，在这多处理系统上是很复杂的，因为多个处理器共享一个缓存。
- 进程在被调度的时候需要切换上下文，可能是主动地，也有可能是被动的：
  1. 系统进程正常调度算法导致进程上下文切换。例如目前使用的**时间片轮转算法**，当一个进程的时间片耗尽之后，CPU会将进程调度切换到其他进程。
  2. 进程在**资源不足**的时候，会被挂起。例如在等待IO或者内存不足的时候，会主动挂起，并且等待系统调度其他进程。
  3. 当进程通过一些睡眠函数**sleep()主动**挂起的时候，也会重新调度。
  4. 当有高优先级的进程运行时，当前进程也会被挂起。**(抢占)**。
  5. 当发生**硬件中断**时，CPU上的进程会被中断挂起。

### 线程上下文
- 线程上下文切换，分为两种情况：
  1. 前后两个线程属于不同进程，因为资源不共享，所以这时候的线程上下文切换和进程上下文切换是一致的。
  2. 前后两个线程属于不同进程，因为资源不共享，所以这时候的线程上下文切换和进程上下文切换是一致的。所以同进程内的线程切换要比多进程内的线程切换消耗更少的资源。

### 中断上下文
- 中断是为了快速响应硬件的事件——计算机停下当前的事情，去处理其他的事情，然后在回来继续执行之前的任务。
- 例如在调用print函数的时候，其实汇编的底层会调用一条**int 0x80**的指令，便是调用0x80号中断。
- 中断要先将当前进程的状态保存下来，这样中断结束后进程仍然可以从原来的状态恢复运行，中断上下文的切换并不涉及进程的用户态，所以当中断程序打断了正在处于用户态的进程，不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源，只需要保存和恢复这个进程的内核态中的资源包括CPU寄存器、内核堆栈等。
- 对于同一个CPU来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生，一般来说中断程序都执行比较快短小精悍，以便快速结束执行之前的任务。
- 当中断上下文切换次数比较多的时候，会耗费大量的CPU时间。所以运行在中断上下文的代码不能做以下几件事：
  1. 睡眠或者放弃CPU，因为内核在进入中断之前会关闭进程调度，一旦睡眠或者放弃CPU，这时内核无法调度别的进程来执行，系统就会死掉。
  2. 尝试获得信号量，如果或得不到信号量，代码就会睡眠，结果同上。
  3. 执行耗时的任务，中断处理应该尽可能快，因为内核要相应大量服务和请求，中断上下文占用CPU时间太长会严重影响系统功能。
  4. 访问用户空间的虚拟地址，中断上下文是和特定进程无关的，它是内核代表硬件运行在内核空间，所以在无法访问用户空间的虚拟地址。

### 查看CPU上下文切换情况
- `vmstat`是一个Linux常用的系统性能分析工具，可以用来分析CPU上下文切换和中断的次数。
  - `vmstat`工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数，单位是秒，第二个参数是采样的次数。
  - 输出参数
    - `cs`(context switch)：每秒上下文切换的次数。
    - `in`(interrupt)：每秒中断的次数。
      - 可以使用`cat`命令查看`/proc/interrupts`读取中断详细情况。
    - `r`(Running or Runnable)：就绪队列的长度，也就是正在运行和等待CPU的进程。
    - `b`(Blocked)：处于不可中断睡眠状态的进程数。
- 要想查看每个进程的详细情况就需要使用`pidstat`，加上`-w`选项就可以查看进程上下文切换的情况:
  - 输出参数
    - `cswch`(voluntary context switches)：表示每秒**自愿上下文切换**的次数。
      - 自愿上下文切换：进程无法获取所需的资源，导致的上下文切换，例如IO、内存等资源不足时，就会发生自愿上下文切换。
    - `nvcswch`(non voluntary context switches)：表示每秒**非自愿上下文切换**的次数。
      - 非自愿上下文切换：进程由于时间片已到等时间，被系统强制调度，进而发生的上下文切换，例如大量的进程都在争抢CPU时，就容易发生非自愿上下文切换。

### CPU上下文切换次数与性能的关系
- 自愿上下文切换变多了，说明进程都在等待资源，有可能发生了I/O 等其他问题；
- 非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢CPU，说明CPU的确成了瓶颈；
- 中断次数变多了，说明CPU被中断处理程序占用，还需要通过查看/proc/interrupts文件查看中断调用详情再做判断。
