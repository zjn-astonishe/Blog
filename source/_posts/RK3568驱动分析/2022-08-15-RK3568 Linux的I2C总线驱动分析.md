---
title: RK3568 Linux的I2C总线驱动分析
date: 2022-08-15 11:59:02 +0800
categories: [Linux, RK3568, I2C驱动, 代码分析]
tag: [Linux设备驱动, RK3568]
mathjax: true
---

# RK3568 Linux的I2C总线驱动分析

## 前言

由于Linux的总线、设备和驱动模型实际是一个树形结构，每个节点可以既是设备所挂载的总线，同时也是挂载在上一层总线的设备。尽管I2C适配器为设备提供了总线，但本身也被认为是挂载在 `platform` 总线上的一个设备。经由I2C总线驱动，不仅可以控制I2C适配器以主控方式产生开始位、停止位、读写周期，还能以从设备方式被读写、产生ACK等。

## RK3568 I2C总线驱动概述

* 文件路径
  + `.../OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-rk3x.c`
* 总线驱动：`rk3x_i2c_driver`：
  + probe方法：`rk3x_i2c_probe`
  + remove方法：`rk3x_i2c_remove`
* 通信方法集合：`rk3x_i2c_algorithm`
  + 通信方法：`rk3x_i2c_xfer`
  + 功能检测方法：`rk3x_i2c_func`
* 驱动注册和卸载方法
  + `module_platform_driver`

## 总线驱动定义

```C++
static struct platform_driver rk3x_i2c_driver = {

	.probe   = rk3x_i2c_probe,                      
	.remove  = rk3x_i2c_remove,
	.driver  = {
		.name  = "rk3x-i2c",
		.of_match_table = rk3x_i2c_match,
		.pm = &rk3x_i2c_pm_ops,
	},

}; 

```

```C++
struct platform_driver {
/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
 int (*probe)(struct platform_device *);
 int (*remove)(struct platform_device *);
 void (*shutdown)(struct platform_device *);
 int (*suspend)(struct platform_device *, pm_message_t state);
/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
 int (*resume)(struct platform_device *);
 struct device_driver driver;
};
```

```C++
struct device_driver {

	const char		*name;
	struct bus_type		*bus;

	struct module		*owner;
	const char		*mod_name;	/* used for built-in modules */

	bool suppress_bind_attrs;	/* disables bind/unbind via sysfs */
	enum probe_type probe_type;

	const struct of_device_id	*of_match_table;
	const struct acpi_device_id	*acpi_match_table;

	int (*probe) (struct device *dev);
	void (*sync_state)(struct device *dev);
	int (*remove) (struct device *dev);
	void (*shutdown) (struct device *dev);
	int (*suspend) (struct device *dev, pm_message_t state);
	int (*resume) (struct device *dev);
	const struct attribute_group **groups;
	const struct attribute_group **dev_groups;

	const struct dev_pm_ops *pm;
	void (*coredump) (struct device *dev);

	struct driver_private *p;

}; 

```

## algorithm通信方法定义

## 设备树的分配方法

```C++
static const struct of_device_id rk3x_i2c_match[] = {
	{
		.compatible = "rockchip,rv1108-i2c",
		.data = &rv1108_soc_data
	},
	{
		.compatible = "rockchip,rv1126-i2c",
		.data = &rv1126_soc_data
	},
	{
		.compatible = "rockchip,rk3066-i2c",
		.data = &rk3066_soc_data
	},
	{
		.compatible = "rockchip,rk3188-i2c",
		.data = &rk3188_soc_data
	},
	{
		.compatible = "rockchip,rk3228-i2c",
		.data = &rk3228_soc_data
	},
	{
		.compatible = "rockchip,rk3288-i2c",
		.data = &rk3288_soc_data
	},
	{
		.compatible = "rockchip,rk3399-i2c",
		.data = &rk3399_soc_data
	},
	{},
};
```

## 注册平台驱动

## 总线驱动函数

### 初始化函数probe()

### 释放函数remove()

### 通信方法函数xfer()

### 功能检测函数func()

### 总线驱动模块注册函数init()

### 总线驱动模块卸载函数exit()
