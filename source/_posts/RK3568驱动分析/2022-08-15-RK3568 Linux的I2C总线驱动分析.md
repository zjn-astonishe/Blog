---
title: RK3568 Linux的I2C总线驱动分析
date: 2022-08-15 11:59:02 +0800
categories: [Linux, RK3568, I2C驱动, 代码分析]
tag: [Linux设备驱动, RK3568]
mathjax: true
---

# RK3568 Linux的I2C总线驱动分析

## 前言

Linux的总线、设备和驱动模型实际是一个树形结构，每个节点可以既是设备所挂载的总线，同时也是挂载在上一层总线的设备。因此，尽管I2C适配器为设备提供了总线，但本身也被认为是挂载在 `platform` 总线上的一个设备。经由I2C总线驱动，不仅可以控制I2C适配器以主控方式产生开始位、停止位、读写周期，还能以从设备方式被读写、产生ACK等。

## RK3568 I2C总线驱动概述

* 文件路径
  + `.../OpenHarmony/out/kernel/src_tmp/linux-5.10/drivers/i2c/busses/i2c-rk3x.c`
* 总线驱动：`rk3x_i2c_driver`：
  + probe方法：`rk3x_i2c_probe`
  + remove方法：`rk3x_i2c_remove`
  + 设备树匹配：`rk3x_i2c_match`
* 通信方法集合：`rk3x_i2c_algorithm`
  + 通信方法：`rk3x_i2c_xfer`
  + 功能检测方法：`rk3x_i2c_func`
* 驱动注册和卸载方法
  + `module_platform_driver`
* 设备树文件
  + `.../OpenHarmony/out/kernel/src_tmp/linux-5.10/arch/arm64/boot/dts/rockchip/rk3568.dtsi`

## 总线驱动定义

因为I2C适配器是要挂载到 `platform` 总线，所以填充 `platform_driver` 结构体以定义I2C总线驱动。

```C++
static struct platform_driver rk3x_i2c_driver = {

	.probe   = rk3x_i2c_probe,      // 当驱动注册完毕，并且匹配成功，则会自动调用该方法对硬件进行操作：
                                    // a. 注册设备号，并且注册fops(为用户提供设备标示，同时提供文件操作io接口)
                                    // b. 创建设备节点
                                    // c. 初始化硬件的各项信息，如ioremap(io地址映射虚拟地址)
                                    // d. 实现各种io功能接口
	.remove  = rk3x_i2c_remove,
	.driver  = {
		.name  = "rk3x-i2c",                // 用于驱动和设备匹配，确保驱动和设备一致，否则无法匹配成功
		.of_match_table = rk3x_i2c_match,   // 匹配方法
		.pm = &rk3x_i2c_pm_ops,	            // dev_pm_ops类型的结构体，用来赋值设备完成运行时的电源管理
	},

}; 

```

## algorithm通信方法定义

```C++
static const struct i2c_algorithm rk3x_i2c_algorithm = {
	.master_xfer		= rk3x_i2c_xfer,             // 通信方法
	.master_xfer_atomic	= rk3x_i2c_xfer_polling,     // 通信方法，仅使用于原子上下文
	.functionality		= rk3x_i2c_func,             // 检测通信方法支持的功能或协议
};
```

## 设备树的分配方法

```C++

	i2c0: i2c@fdd40000 {
		compatible = "rockchip,rk3399-i2c";
		reg = <0x0 0xfdd40000 0x0 0x1000>;
		clocks = <&pmucru CLK_I2C0>, <&pmucru PCLK_I2C0>;
		clock-names = "i2c", "pclk";
		interrupts = <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>;
		pinctrl-names = "default";
		pinctrl-0 = <&i2c0_xfer>;
		#address-cells = <1>;
		#size-cells = <0>;
		status = "disabled";
	};
	i2c1: i2c@fe5a0000 {
		compatible = "rockchip,rk3399-i2c";
		reg = <0x0 0xfe5a0000 0x0 0x1000>;
		clocks = <&cru CLK_I2C1>, <&cru PCLK_I2C1>;
		clock-names = "i2c", "pclk";
		interrupts = <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>;
		pinctrl-names = "default";
		pinctrl-0 = <&i2c1_xfer>;
		#address-cells = <1>;
		#size-cells = <0>;
		status = "disabled";
	};
	i2c2: i2c@fe5b0000 {
		compatible = "rockchip,rk3399-i2c";
		reg = <0x0 0xfe5b0000 0x0 0x1000>;
		clocks = <&cru CLK_I2C2>, <&cru PCLK_I2C2>;
		clock-names = "i2c", "pclk";
		interrupts = <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
		pinctrl-names = "default";
		pinctrl-0 = <&i2c2m0_xfer>;
		#address-cells = <1>;
		#size-cells = <0>;
		status = "disabled";
	};
	i2c3: i2c@fe5c0000 {
		compatible = "rockchip,rk3399-i2c";
		reg = <0x0 0xfe5c0000 0x0 0x1000>;
		clocks = <&cru CLK_I2C3>, <&cru PCLK_I2C3>;
		clock-names = "i2c", "pclk";
		interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>;
		pinctrl-names = "default";
		pinctrl-0 = <&i2c3m0_xfer>;
		#address-cells = <1>;
		#size-cells = <0>;
		status = "disabled";
	};
	i2c4: i2c@fe5d0000 {
		compatible = "rockchip,rk3399-i2c";
		reg = <0x0 0xfe5d0000 0x0 0x1000>;
		clocks = <&cru CLK_I2C4>, <&cru PCLK_I2C4>;
		clock-names = "i2c", "pclk";
		interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
		pinctrl-names = "default";
		pinctrl-0 = <&i2c4m0_xfer>;
		#address-cells = <1>;
		#size-cells = <0>;
		status = "disabled";
	};
	i2c5: i2c@fe5e0000 {
		compatible = "rockchip,rk3399-i2c";
		reg = <0x0 0xfe5e0000 0x0 0x1000>;
		clocks = <&cru CLK_I2C5>, <&cru PCLK_I2C5>;
		clock-names = "i2c", "pclk";
		interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
		pinctrl-names = "default";
		pinctrl-0 = <&i2c5m0_xfer>;
		#address-cells = <1>;
		#size-cells = <0>;
		status = "disabled";
	};

```

RK3568共有6个I2C控制器，分别为I2C0~I2C5，每个控制器对应不同的寄存器基地址(i2c0是0xfdd40000)， `.compatible` 属性都是 `rockchip, rk3399-i2c` ，即对应了同一个adapter驱动。

```C++
// rk3x_i2c_driver结构体中.driver的匹配表参数
static const struct of_device_id rk3x_i2c_match[] = {
	{
		.compatible = "rockchip,rv1108-i2c",
		.data = &rv1108_soc_data
	},
	{
		.compatible = "rockchip,rv1126-i2c",
		.data = &rv1126_soc_data
	},
	{
		.compatible = "rockchip,rk3066-i2c",
		.data = &rk3066_soc_data
	},
	{
		.compatible = "rockchip,rk3188-i2c",
		.data = &rk3188_soc_data
	},
	{
		.compatible = "rockchip,rk3228-i2c",
		.data = &rk3228_soc_data
	},
	{
		.compatible = "rockchip,rk3288-i2c",
		.data = &rk3288_soc_data
	},
	{
		.compatible = "rockchip,rk3399-i2c", // 符合DTS中描述的匹配字符串
		.data = &rk3399_soc_data
	},
	{},
};
/**
 * @param usb               设备名
 * @param skel_table        该设备加入到模块中时对应产生的设备搜索符号
 * @return 生成一个名为__mod_pci_device_table局部变量，这个变量指向第二个参数
 */
MODULE_DEVICE_TABLE(of, rk3x_i2c_match); // 两个功能，一是将设备加入到外设队列中，二是告诉程序阅读者该设备是热插拔设备或支持热插拔功能。
```

### 总线驱动注册和卸载方法

```C++
module_platform_driver(rk3x_i2c_driver); 
```

## 总线驱动函数

### 初始化函数probe()

### 释放函数remove()

### 通信方法函数xfer()

### 功能检测函数func()
