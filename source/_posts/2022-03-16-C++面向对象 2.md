---
title: C++面向对象 2
date: 2022-03-16 16:41:37 +0800
categories: C/C++
tag: [C/C++面经, 面向对象]
mathjax: true
---

# C++面向对象 2

## 构造函数和析构函数

### 对拷贝构造函数、深浅拷贝的理解。拷贝构造函数作用及用途？什么时候需要自定义拷贝构造函数？
- 浅拷贝是增加了一个指针，指向原来已经存在的内存。
  - 浅拷贝在多个对象指向同一块空间的时候，释放一个空间会导致其他对象所使用的空间也被释放，其他空间再次释放会出现错误。
- 深拷贝是增加了一个指针，并新开辟了一块空间让指针指向这块新开辟的空间。
- 深拷贝和浅拷贝的不同之处，仅仅在于修改了拷贝构造函数，以及赋值运算符的重载。相同类型的类对象是通过拷贝构造函数来完成复制过程的。
```C++
#include <iostream>
#include <cstring>
using namespace std;

class CopyDemo
{
public:
  CopyDemo(int pa,char *cstr)  //构造函数，两个参数
  {
    this->a = pa;
    this->str = new char[1024]; //指针数组，动态的用new在堆上分配存储空间
    strcpy(this->str,cstr);    //拷贝过来
  }

// 没写，C++会自动帮忙写一个复制构造函数，这个默认拷贝构造函数执行的是浅拷贝。
// 浅拷贝只复制指针,如下注释部分
  CopyDemo(CopyDemo& obj)  
  {
    this->a = obj.a;
    this->str = obj.str; // 这里是浅复制会出问题，要深复制
  }
/*
  CopyDemo(CopyDemo& obj)  //一般数据成员有指针要自己写复制构造函数，如下
  {
    this->a = obj.a;
    this->str = new char[1024];// 深复制
    if(str != 0)
      strcpy(this->str,obj.str); // 如果成功，把内容复制过来
  }
*/
  ~CopyDemo()  //析构函数
  {
    delete str;
  }
public:
  int a;  //定义一个整型的数据成员
  char *str; //字符串指针
};
int main()
{
  CopyDemo A(100,"hello!!!");
  CopyDemo B = A;  //复制构造函数，把A的10和hello!!!复制给B
  cout <<"A:"<< A.a << "," <<A.str << endl;
  //输出A:100，hello!!!
  cout <<"B:"<< B.a << "," <<B.str << endl;
  //输出B:100，hello!!!
  //修改后,发现A,B都被改变，原因就是浅复制，A,B指针指向同一地方，修改后都改变
  B.a = 80;
  B.str[0] = 'k';
  cout <<"A:"<< A.a << "," <<A.str << endl;
  //输出A:100，kello!!!
  cout <<"B:"<< B.a << "," <<B.str << endl;
  //输出B:80，kello!!!
  return 0;
}
```
- 对于凡是包含动态分配成员或包含指针成员(如字符串)的类都应该提供拷贝构造函数；在提供拷贝构造函数的同时，还应该考虑重载"="赋值操作符号。

### 调用拷贝构造函数的三种情况
- 一个对象以值传递的方式传入函数体(形参)
  ```C++
  //全局函数，传入的是对象
  void g_Fun(CExample C)
  {
      cout<<"test"<<endl;
  }
  int main()
  {
      CExample test(1);
      //传入对象
      g_Fun(test);
  }
  /**
   * 调用g_Fun()时，会产生以下几个重要步骤：
    * (1)test对象传入形参时，会先会产生一个临时变量，就叫tmp_test吧。
    * (2)然后调用拷贝构造函数把test的值给tmp_test。整个这两个步骤有点像：
    *    CExample tmp_test(test);
    * (3)等g_Fun()执行完后,析构掉tmp_test对象。
    * */
  ```
- 一个对象以值传递的方式返回(返回值)
  ```C++
  //全局函数
  CExample g_Fun()
  {
      CExample temp(0);
      return temp;
  }
  int main()
  {
      g_Fun();
  }
  /**
   * 当g_Fun()函数执行到return时，会产生以下几个重要步骤：
   * (1)先会产生一个临时变量，就叫XXXX吧。
   * (2)然后调用拷贝构造函数把temp的值给XXXX。整个这两个步骤有点像：CExample XXXX(temp);
   * (3)在函数执行到最后先析构temp局部变量。
   * (4)等g_Fun()执行完后再析构掉XXXX对象.
   * */
  ```
- 一个对象需要通过另外一个对象进行初始化(初始化)
  ```C++
    CExample A(100);
    CExample B = A; //这句和下句都会调用拷贝构造函数。
    // CExample B(A);
  ```

### 构造函数为什么一般不定义为虚函数
- 从存储空间角度
- 从使用角度
- 从实现角度
- 构造函数不需要是虚函数，
- 当一个构造函数被调用的时候

### 析构函数可以抛出异常吗？为什么？除了资源泄露，还会造成怎样的影响？
- C++标准指明析构函数不能、也不应该抛出异常。
  - 如果对象在运行期间出现了异常，C++异常处理模型有责任清楚由于异常导致失效的对象(对象超出了原来的作用域)，并释放对象原来所分配的资源。而释放资源的任务是由对象的析构函数完成的。所以，某种意义上说，析构函数已经变成了异常处理的一部分。
- 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作，比如释放资源，则这些动作不会执行，没有释放的资源便造成了资源泄露问题。
- 通常在异常发生时，C++的机制会调用已经构造对象的析构函数释放资源，此时若析构函数本身也抛出异常，则会出现程序崩溃问题。例如在析构函数里delete this指针，该操作会调用析构函数，那么就会陷入死循环造成程序崩溃。

